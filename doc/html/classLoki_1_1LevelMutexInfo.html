<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>tetcutter: Loki::LevelMutexInfo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tetcutter
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">High-Performance cutting tetrahedral meshes.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoki.html">Loki</a></li><li class="navelem"><a class="el" href="classLoki_1_1LevelMutexInfo.html">LevelMutexInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classLoki_1_1LevelMutexInfo-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loki::LevelMutexInfo Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="LevelMutex_8h_source.html">LevelMutex.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Loki::LevelMutexInfo:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLoki_1_1LevelMutexInfo.png" usemap="#Loki::LevelMutexInfo_map" alt=""/>
  <map id="Loki::LevelMutexInfo_map" name="Loki::LevelMutexInfo_map">
<area href="classLoki_1_1LevelMutex.html" alt="Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;" shape="rect" coords="0,56,421,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo_1_1Checker.html">Checker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo_1_1MutexUndoer.html">MutexUndoer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a76a0315d91234f5066c75660a9f27a7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76a0315d91234f5066c75660a9f27a7f"></a>
typedef ::std::vector&lt; volatile <a class="el" href="classLoki_1_1LevelMutexInfo.html">LevelMutexInfo</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a76a0315d91234f5066c75660a9f27a7f">MutexContainer</a></td></tr>
<tr class="memdesc:a76a0315d91234f5066c75660a9f27a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for locking multiple mutexes at once. <br /></td></tr>
<tr class="separator:a76a0315d91234f5066c75660a9f27a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113155a861291e24efb80ecb795ced42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a113155a861291e24efb80ecb795ced42"></a>
typedef MutexContainer::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>LevelMutexContainerIter</b></td></tr>
<tr class="separator:a113155a861291e24efb80ecb795ced42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a0f71a067b3c6028ca10010a740cee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18a0f71a067b3c6028ca10010a740cee"></a>
typedef MutexContainer::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>LevelMutexContainerCIter</b></td></tr>
<tr class="separator:a18a0f71a067b3c6028ca10010a740cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc582d1025baad1f014d3604e293b4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecc582d1025baad1f014d3604e293b4d"></a>
typedef MutexContainer::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>LevelMutexContainerRIter</b></td></tr>
<tr class="separator:aecc582d1025baad1f014d3604e293b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aedd07ffe486369939e0fb4c0bb1074"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4aedd07ffe486369939e0fb4c0bb1074"></a>
typedef MutexContainer::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>LevelMutexContainerCRIter</b></td></tr>
<tr class="separator:a4aedd07ffe486369939e0fb4c0bb1074"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abdedfcacd393739737f1792cdf5a1c85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdedfcacd393739737f1792cdf5a1c85"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#abdedfcacd393739737f1792cdf5a1c85">GetLevel</a> (void) const  volatile</td></tr>
<tr class="memdesc:abdedfcacd393739737f1792cdf5a1c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the level of this mutex. <br /></td></tr>
<tr class="separator:abdedfcacd393739737f1792cdf5a1c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b8448224912bb4d666ac8e0590541"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a579b8448224912bb4d666ac8e0590541"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a579b8448224912bb4d666ac8e0590541">IsLocked</a> (void) const  volatile</td></tr>
<tr class="memdesc:a579b8448224912bb4d666ac8e0590541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this mutex was locked at least once. <br /></td></tr>
<tr class="separator:a579b8448224912bb4d666ac8e0590541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8ad4b0cbc81c3875db1e1cb8c05e91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd8ad4b0cbc81c3875db1e1cb8c05e91"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#abd8ad4b0cbc81c3875db1e1cb8c05e91">GetLockCount</a> (void) const  volatile</td></tr>
<tr class="memdesc:abd8ad4b0cbc81c3875db1e1cb8c05e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns count of how many times this mutex got locked. <br /></td></tr>
<tr class="separator:abd8ad4b0cbc81c3875db1e1cb8c05e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73937a31d5902e74752708c3b2917327"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73937a31d5902e74752708c3b2917327"></a>
const volatile <a class="el" href="classLoki_1_1LevelMutexInfo.html">LevelMutexInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a73937a31d5902e74752708c3b2917327">GetPrevious</a> (void) const  volatile</td></tr>
<tr class="memdesc:a73937a31d5902e74752708c3b2917327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to mutex previously locked by the thread which locked this. <br /></td></tr>
<tr class="separator:a73937a31d5902e74752708c3b2917327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f89bf087b932de0cdd1151116779b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a32f89bf087b932de0cdd1151116779b4">TryLock</a> (void) volatile=0</td></tr>
<tr class="separator:a32f89bf087b932de0cdd1151116779b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e21e08ee9974533a4da5008452bd04"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#ac0e21e08ee9974533a4da5008452bd04">Lock</a> (void) volatile=0</td></tr>
<tr class="separator:ac0e21e08ee9974533a4da5008452bd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5782b9fd9734d95a38ff86ef9532c89b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a5782b9fd9734d95a38ff86ef9532c89b">Lock</a> (unsigned int milliSeconds) volatile=0</td></tr>
<tr class="separator:a5782b9fd9734d95a38ff86ef9532c89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c9af5cb0f6870585b864b4557e9242"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a01c9af5cb0f6870585b864b4557e9242">Unlock</a> (void) volatile=0</td></tr>
<tr class="separator:a01c9af5cb0f6870585b864b4557e9242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dd128d5864ad0ffe9fa55912e11c5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#ae2dd128d5864ad0ffe9fa55912e11c5c">IsRecentLock</a> (void) const  volatile</td></tr>
<tr class="separator:ae2dd128d5864ad0ffe9fa55912e11c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf885ea3edb574c902e61a9a97cd4933"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#acf885ea3edb574c902e61a9a97cd4933">IsRecentLock</a> (unsigned int count) const  volatile</td></tr>
<tr class="separator:acf885ea3edb574c902e61a9a97cd4933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc33a319dd0aab4df4d95a557eeda0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bc33a319dd0aab4df4d95a557eeda0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a9bc33a319dd0aab4df4d95a557eeda0f">IsLockedByCurrentThread</a> (void) const  volatile</td></tr>
<tr class="memdesc:a9bc33a319dd0aab4df4d95a557eeda0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this was locked by current thread. <br /></td></tr>
<tr class="separator:a9bc33a319dd0aab4df4d95a557eeda0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0f3e952926fca76d2921b47d3b9457"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c0f3e952926fca76d2921b47d3b9457"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a3c0f3e952926fca76d2921b47d3b9457">IsLockedByAnotherThread</a> (void) const  volatile</td></tr>
<tr class="memdesc:a3c0f3e952926fca76d2921b47d3b9457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this was locked by another thread. <br /></td></tr>
<tr class="separator:a3c0f3e952926fca76d2921b47d3b9457"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adde650eae1cad8b4723e68cdb9130283"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#adde650eae1cad8b4723e68cdb9130283">MultiLock</a> (<a class="el" href="classLoki_1_1LevelMutexInfo.html#a76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;mutexes)</td></tr>
<tr class="separator:adde650eae1cad8b4723e68cdb9130283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76848d3aa8e6c66454bd5357f715583"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#aa76848d3aa8e6c66454bd5357f715583">MultiLock</a> (<a class="el" href="classLoki_1_1LevelMutexInfo.html#a76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;mutexes, unsigned int milliSeconds)</td></tr>
<tr class="separator:aa76848d3aa8e6c66454bd5357f715583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475d734ba0e756935462a5151ea98065"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a475d734ba0e756935462a5151ea98065">MultiUnlock</a> (<a class="el" href="classLoki_1_1LevelMutexInfo.html#a76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;mutexes)</td></tr>
<tr class="separator:a475d734ba0e756935462a5151ea98065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fd94847721b118979b72121472d3e2"><td class="memItemLeft" align="right" valign="top">static const volatile <a class="el" href="classLoki_1_1LevelMutexInfo.html">LevelMutexInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#ab7fd94847721b118979b72121472d3e2">GetCurrentMutex</a> (void)</td></tr>
<tr class="separator:ab7fd94847721b118979b72121472d3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1f68bae408eb26856776cf02efed90bc"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a1f68bae408eb26856776cf02efed90bc">UnlockedLevel</a> = 0xFFFFFFFF</td></tr>
<tr class="separator:a1f68bae408eb26856776cf02efed90bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0e7b01d7e0aad6710f34de9811a88151"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a0e7b01d7e0aad6710f34de9811a88151">LevelMutexInfo</a> (unsigned int level)</td></tr>
<tr class="separator:a0e7b01d7e0aad6710f34de9811a88151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6713a7bc49313e970c91cfeb208d0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d6713a7bc49313e970c91cfeb208d0e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a5d6713a7bc49313e970c91cfeb208d0e">~LevelMutexInfo</a> (void)</td></tr>
<tr class="memdesc:a5d6713a7bc49313e970c91cfeb208d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor only gets called by the derived class. <br /></td></tr>
<tr class="separator:a5d6713a7bc49313e970c91cfeb208d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648ffd0040be4464e342d45e8d029972"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a648ffd0040be4464e342d45e8d029972"></a>
<a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PreLockCheck</b> (bool forTryLock) volatile</td></tr>
<tr class="separator:a648ffd0040be4464e342d45e8d029972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc21f5357f74a3b137dded520e35e489"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc21f5357f74a3b137dded520e35e489"></a>
<a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PreUnlockCheck</b> (void) volatile</td></tr>
<tr class="separator:adc21f5357f74a3b137dded520e35e489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe2ecf1bcf2c49eae04c493f023099c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a3fe2ecf1bcf2c49eae04c493f023099c">PostLock</a> (void) volatile</td></tr>
<tr class="separator:a3fe2ecf1bcf2c49eae04c493f023099c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5e2ace54e9423866be7c76116423df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d5e2ace54e9423866be7c76116423df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a7d5e2ace54e9423866be7c76116423df">PreUnlock</a> (void) volatile</td></tr>
<tr class="memdesc:a7d5e2ace54e9423866be7c76116423df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets called just before an attempt to unlock a mutex. <br /></td></tr>
<tr class="separator:a7d5e2ace54e9423866be7c76116423df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31292dd7d1a944b8db2ba39a8487f3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab31292dd7d1a944b8db2ba39a8487f3b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#ab31292dd7d1a944b8db2ba39a8487f3b">IncrementCount</a> (void) volatile</td></tr>
<tr class="memdesc:ab31292dd7d1a944b8db2ba39a8487f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to relock a mutex already locked by the current thread. <br /></td></tr>
<tr class="separator:ab31292dd7d1a944b8db2ba39a8487f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929c6964d78855d487a4fd72ef8e3332"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a929c6964d78855d487a4fd72ef8e3332"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a929c6964d78855d487a4fd72ef8e3332">DecrementCount</a> (void) volatile</td></tr>
<tr class="memdesc:a929c6964d78855d487a4fd72ef8e3332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to unlock a mutex locked multiple times by the current thread. <br /></td></tr>
<tr class="separator:a929c6964d78855d487a4fd72ef8e3332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479a20cf2f8da0ef5bed07cdef45b119"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a479a20cf2f8da0ef5bed07cdef45b119">IsValid</a> (void) const  volatile</td></tr>
<tr class="separator:a479a20cf2f8da0ef5bed07cdef45b119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a01f6dfba5d2ea5606109b34e5a543cf0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a01f6dfba5d2ea5606109b34e5a543cf0">IsValidList</a> (void)</td></tr>
<tr class="separator:a01f6dfba5d2ea5606109b34e5a543cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This monolithic base class stores common info for a template class used to control mutexes. The template class, <a class="el" href="classLoki_1_1LevelMutex.html">LevelMutex</a>, is policy-based class.</p>
<dl class="section user"><dt>Implementation</dt><dd>Each thread has a list of mutexes it locked. When a mutex first gets locked, it gets added to the head of the list. If locked again, <a class="el" href="classLoki_1_1LevelMutex.html">LevelMutex</a> merely increments a count. When unlocked, the count gets decremented until it reaches zero, and then it gets removed from the list. Each mutex has a pointer to the mutex most recently locked by the current thread. The current level of a thread is always the level of the most recently locked mutex, or UnlockedLevel if the thread does not have any mutexes locked now. <a class="el" href="structA.html">A</a> mutex is considered "recently" locked if it is at the head of the list, or the same level as the current mutex and also locked by the current thread.</dd></dl>
<dl class="section user"><dt>Class Invariants</dt><dd>This class maintains invariants for each <a class="el" href="classLoki_1_1LevelMutexInfo.html">LevelMutexInfo</a> so that no function calls corrupt a mutex. Each function makes a call to IsValid at the start so that <a class="el" href="classLoki_1_1LevelMutex.html">LevelMutex</a> knows it acts on valid internal data. Many functions call IsValid again when they return to insure the function did not leave any data in an invalid state. The exit call to IsValid occurs through a tiny helper class called <a class="el" href="classLoki_1_1LevelMutexInfo_1_1Checker.html">Checker</a> to insure all data remain valid even when exceptions occur. Another helper class, <a class="el" href="classLoki_1_1LevelMutexInfo_1_1MutexUndoer.html">MutexUndoer</a>, unlocks mutexes in a container if an exception occurs during calls to MultiLock.</dd></dl>
<dl class="section user"><dt>Error Results</dt><dd>Many functions return an enum value to indicate an error status. Many enum values indicate errors detected within <a class="el" href="classLoki_1_1LevelMutex.html">LevelMutex</a>, but some indicate errors found in policy classes, <a class="el" href="classLoki_1_1SpinLevelMutex.html">SpinLevelMutex</a> and <a class="el" href="classLoki_1_1SleepLevelMutex.html">SleepLevelMutex</a>. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0e7b01d7e0aad6710f34de9811a88151"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Loki::LevelMutexInfo::LevelMutexInfo </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the only available constructor, and it forces any derived class to set a level for each mutex. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab7fd94847721b118979b72121472d3e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const volatile <a class="el" href="classLoki_1_1LevelMutexInfo.html">LevelMutexInfo</a> * Loki::LevelMutexInfo::GetCurrentMutex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gives pointer to most recently locked mutex, or NULL if nothing locked. The pointer is for a const mutex so the mutex can't be modified inappropriately. The pointer is for a volatile mutex so callers can call volatile member functions to get info about the mutex. </p>

</div>
</div>
<a class="anchor" id="ae2dd128d5864ad0ffe9fa55912e11c5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Loki::LevelMutexInfo::IsRecentLock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this mutex was locked by current thread, and level is the same as the current thread's level. Which means this was the most recently locked mutex, or it was locked along with several others of the same level recently. </p>

</div>
</div>
<a class="anchor" id="acf885ea3edb574c902e61a9a97cd4933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Loki::LevelMutexInfo::IsRecentLock </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this mutex was locked within the last count mutexes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>How many recent mutexes to look through to find this mutex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a479a20cf2f8da0ef5bed07cdef45b119"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loki::LevelMutexInfo::IsValid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if no class invariant broken, otherwise asserts. This function only gets called in debug builds. </p>

</div>
</div>
<a class="anchor" id="a01f6dfba5d2ea5606109b34e5a543cf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loki::LevelMutexInfo::IsValidList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if linked-list of locked mutexes in this thread is valid. Which means the list has no loops, and each previous mutex on the list has a higher or same level as the current mutex. Called by IsValid. </p>

</div>
</div>
<a class="anchor" id="ac0e21e08ee9974533a4da5008452bd04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a> Loki::LevelMutexInfo::Lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocking call will attempt to lock mutex and wait until it can lock. This may throw an exception if the lock failed or an error occurred - if that is what the error policy specifies. </p><dl class="section return"><dt>Returns</dt><dd>An error condition if any occurred, else Success. </dd></dl>

<p>Implemented in <a class="el" href="classLoki_1_1LevelMutex.html#a95d3742db062548201986f482a9c9b9d">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5782b9fd9734d95a38ff86ef9532c89b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a> Loki::LevelMutexInfo::Lock </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>milliSeconds</em></td><td>)</td>
          <td> volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to lock mutex, but only waits for a limited amount of time before it gives up. Will return quickly if an error occurs before any attempt to lock. This may throw an exception if the lock failed or an error occurred - if that is what the error policy specifies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliSeconds</td><td>How long to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error condition if any occurred, else Success. </dd></dl>

<p>Implemented in <a class="el" href="classLoki_1_1LevelMutex.html#ad4ac0c2a33ff3d98ec0a83f70ce145da">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adde650eae1cad8b4723e68cdb9130283"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a> Loki::LevelMutexInfo::MultiLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>mutexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locks several mutexes at once. Requires O(m + n*n) actions where m is the number of mutexes currently locked by the thread and n is the number of mutexes in the container. This provides strong exception safety. If an exception occurs, any mutexes that were locked during this call will get unlocked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutexes</td><td>Container of pointers to mutexes. Container must have at least 1 mutex, all mutexes must have the same level, no NULL pointers, and all mutexes must not exceed the thread's current level. This sorts the container by address order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enum value indicating success or error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa76848d3aa8e6c66454bd5357f715583"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a> Loki::LevelMutexInfo::MultiLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>mutexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>milliSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locks several mutexes at once. Requires O(m + n*n + n*t) actions where m is the number of mutexes currently locked by the thread, n is the number of mutexes in the container, and t is the wait time for each mutex. This provides strong exception safety. If an exception occurs, any mutexes that were locked during this call will ge unlocked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutexes</td><td>Container of pointers to mutexes. Container must have at least 1 mutex, all mutexes must have the same level, no NULL pointers, and all mutexes must not exceed the thread's current level. This sorts the container by address order. </td></tr>
    <tr><td class="paramname">milliSeconds</td><td>Amount of time to wait for each mutex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enum value indicating success or error. </dd></dl>

</div>
</div>
<a class="anchor" id="a475d734ba0e756935462a5151ea98065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a> Loki::LevelMutexInfo::MultiUnlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoki_1_1LevelMutexInfo.html#a76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>mutexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlocks several mutexes at once. Requires O(m) actions where m is the number of mutexes in the container. This provides strong exception safety. If an exception occurs when unlocking one mutex, other mutexes in the container get unlocked anyway. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutexes</td><td>Container of pointers to mutexes. Container must have at least 1 mutex, all mutexes must have the same level, no NULL pointers, and all mutexes must be locked by the current thread. This sorts the container dby address order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enum value indicating success or error. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fe2ecf1bcf2c49eae04c493f023099c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Loki::LevelMutexInfo::PostLock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This gets called after each call to DoLock and DoTryLock to make sure the data members in this object get set correctly. </p>

</div>
</div>
<a class="anchor" id="a32f89bf087b932de0cdd1151116779b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a> Loki::LevelMutexInfo::TryLock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to lock mutex, and returns immediately if mutex already locked by another thread. It will return immediately with a value of AlreadyLocked if the mutex was locked by a different thread. It may throw an exception or assert when errors occur if the ErrorPolicy class implements that behavior. </p><dl class="section return"><dt>Returns</dt><dd>An error condition if any occurred, else Success. </dd></dl>

<p>Implemented in <a class="el" href="classLoki_1_1LevelMutex.html#a042a7938dafd6f149cfd7da46478c0c9">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a01c9af5cb0f6870585b864b4557e9242"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLoki_1_1MutexErrors.html#acd0eb6065ca303083d2e0229d7bff590">MutexErrors::Type</a> Loki::LevelMutexInfo::Unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlocks the mutex, or returns an error condition. This may throw an exception if the lock failed or an error occurred - if that is what the error policy specifies. </p><dl class="section return"><dt>Returns</dt><dd>An error condition if any occurred, else Success. </dd></dl>

<p>Implemented in <a class="el" href="classLoki_1_1LevelMutex.html#a553a379257af57ceaef9ed48b0dc8b70">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a1f68bae408eb26856776cf02efed90bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int Loki::LevelMutexInfo::UnlockedLevel = 0xFFFFFFFF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Level for thread that has not locked any mutex. Maximum possible level for a mutex is UnlockedLevel-1; No mutex may have a level of UnlockedLevel. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/pourya/Desktop/platform/repos/tetcutter/src/3rdparty/loki/include/loki/<a class="el" href="LevelMutex_8h_source.html">LevelMutex.h</a></li>
<li>/Users/pourya/Desktop/platform/repos/tetcutter/src/3rdparty/loki/src/<a class="el" href="LevelMutex_8cpp.html">LevelMutex.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 16 2016 17:37:27 for tetcutter by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
