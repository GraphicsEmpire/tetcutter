<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>tetcutter: tbb::internal::generic_scheduler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tetcutter
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">High-Performance cutting tetrahedral meshes.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetbb.html">tbb</a></li><li class="navelem"><b>internal</b></li><li class="navelem"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html">generic_scheduler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtbb_1_1internal_1_1generic__scheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tbb::internal::generic_scheduler Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structWork.html">Work</a> stealing task scheduler.  
 <a href="classtbb_1_1internal_1_1generic__scheduler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="scheduler_8h_source.html">scheduler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tbb::internal::generic_scheduler:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtbb_1_1internal_1_1generic__scheduler.png" usemap="#tbb::internal::generic_scheduler_map" alt=""/>
  <map id="tbb::internal::generic_scheduler_map" name="tbb::internal::generic_scheduler_map">
<area href="classrml_1_1job.html" title="Represents a client&#39;s job for an execution context. " alt="rml::job" shape="rect" coords="308,0,606,24"/>
<area href="structtbb_1_1internal_1_1scheduler__state.html" alt="tbb::internal::scheduler_state" shape="rect" coords="616,0,914,24"/>
<area href="classtbb_1_1internal_1_1custom__scheduler.html" title="A scheduler with a customized evaluation loop. " alt="tbb::internal::custom_scheduler&lt; SchedulerTraits &gt;" shape="rect" coords="308,112,606,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a951545fe41835b1ca58bf6418aebfb69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a951545fe41835b1ca58bf6418aebfb69"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>in_arena</b> () const </td></tr>
<tr class="separator:a951545fe41835b1ca58bf6418aebfb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228932018abdf86ec504ffc055bf6188"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a228932018abdf86ec504ffc055bf6188"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_local_task_pool_quiescent</b> () const </td></tr>
<tr class="separator:a228932018abdf86ec504ffc055bf6188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5b30c44c0a0a0d6fa6548fead0f879"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b5b30c44c0a0a0d6fa6548fead0f879"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_quiescent_local_task_pool_empty</b> () const </td></tr>
<tr class="separator:a1b5b30c44c0a0a0d6fa6548fead0f879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fe4dd6cf0d0bd7db3440ff1f5e70ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41fe4dd6cf0d0bd7db3440ff1f5e70ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_quiescent_local_task_pool_reset</b> () const </td></tr>
<tr class="separator:a41fe4dd6cf0d0bd7db3440ff1f5e70ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab89891d3c1e3209cffced8bf93b124"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ab89891d3c1e3209cffced8bf93b124"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>attach_mailbox</b> (affinity_id id)</td></tr>
<tr class="separator:a5ab89891d3c1e3209cffced8bf93b124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd799eae7903abc75b7a7aafd36e20db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd799eae7903abc75b7a7aafd36e20db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#afd799eae7903abc75b7a7aafd36e20db">init_stack_info</a> ()</td></tr>
<tr class="memdesc:afd799eae7903abc75b7a7aafd36e20db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the data necessary for the stealing limiting heuristics. <br /></td></tr>
<tr class="separator:afd799eae7903abc75b7a7aafd36e20db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c00f465a90ee09a240d1f81de5f635b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c00f465a90ee09a240d1f81de5f635b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a1c00f465a90ee09a240d1f81de5f635b">can_steal</a> ()</td></tr>
<tr class="memdesc:a1c00f465a90ee09a240d1f81de5f635b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if stealing is allowed. <br /></td></tr>
<tr class="separator:a1c00f465a90ee09a240d1f81de5f635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e93c1283fad6f681e6d0f0f50cf515a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e93c1283fad6f681e6d0f0f50cf515a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a6e93c1283fad6f681e6d0f0f50cf515a">do_enter_arena</a> ()</td></tr>
<tr class="memdesc:a6e93c1283fad6f681e6d0f0f50cf515a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions common to enter_arena and try_enter_arena. <br /></td></tr>
<tr class="separator:a6e93c1283fad6f681e6d0f0f50cf515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b7abb0919184fb3a19b3e865a11dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a28b7abb0919184fb3a19b3e865a11dcc">enter_arena</a> ()</td></tr>
<tr class="memdesc:a28b7abb0919184fb3a19b3e865a11dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by workers to enter the arena.  <a href="#a28b7abb0919184fb3a19b3e865a11dcc">More...</a><br /></td></tr>
<tr class="separator:a28b7abb0919184fb3a19b3e865a11dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e07b903e093bff04e8d9de4fdbab70f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a2e07b903e093bff04e8d9de4fdbab70f">leave_arena</a> ()</td></tr>
<tr class="memdesc:a2e07b903e093bff04e8d9de4fdbab70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave the arena.  <a href="#a2e07b903e093bff04e8d9de4fdbab70f">More...</a><br /></td></tr>
<tr class="separator:a2e07b903e093bff04e8d9de4fdbab70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28f8ec4bb8dab580d3452d58a84ebbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#ae28f8ec4bb8dab580d3452d58a84ebbe">reset_deque_and_leave_arena</a> (bool locked)</td></tr>
<tr class="memdesc:ae28f8ec4bb8dab580d3452d58a84ebbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets head and tail indices to 0, and leaves arena.  <a href="#ae28f8ec4bb8dab580d3452d58a84ebbe">More...</a><br /></td></tr>
<tr class="separator:ae28f8ec4bb8dab580d3452d58a84ebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bc27fa6c9a0cea424ced83b9f020ac"><td class="memItemLeft" align="right" valign="top">task **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a28bc27fa6c9a0cea424ced83b9f020ac">lock_task_pool</a> (<a class="el" href="structtbb_1_1internal_1_1arena__slot.html">arena_slot</a> *victim_arena_slot) const </td></tr>
<tr class="memdesc:a28bc27fa6c9a0cea424ced83b9f020ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks victim's task pool, and returns pointer to it. The pointer can be NULL.  <a href="#a28bc27fa6c9a0cea424ced83b9f020ac">More...</a><br /></td></tr>
<tr class="separator:a28bc27fa6c9a0cea424ced83b9f020ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6340b7bd950b0492e970ff62433198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a5d6340b7bd950b0492e970ff62433198">unlock_task_pool</a> (<a class="el" href="structtbb_1_1internal_1_1arena__slot.html">arena_slot</a> *victim_arena_slot, task **victim_task_pool) const </td></tr>
<tr class="memdesc:a5d6340b7bd950b0492e970ff62433198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks victim's task pool.  <a href="#a5d6340b7bd950b0492e970ff62433198">More...</a><br /></td></tr>
<tr class="separator:a5d6340b7bd950b0492e970ff62433198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2af1d0f7af34dee87a5b207d498f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a6e2af1d0f7af34dee87a5b207d498f59">acquire_task_pool</a> () const </td></tr>
<tr class="memdesc:a6e2af1d0f7af34dee87a5b207d498f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the local task pool.  <a href="#a6e2af1d0f7af34dee87a5b207d498f59">More...</a><br /></td></tr>
<tr class="separator:a6e2af1d0f7af34dee87a5b207d498f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dd9ef31d1f73ea2fadcc35df6d9d21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a24dd9ef31d1f73ea2fadcc35df6d9d21">release_task_pool</a> () const </td></tr>
<tr class="memdesc:a24dd9ef31d1f73ea2fadcc35df6d9d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the local task pool.  <a href="#a24dd9ef31d1f73ea2fadcc35df6d9d21">More...</a><br /></td></tr>
<tr class="separator:a24dd9ef31d1f73ea2fadcc35df6d9d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a62642cb4b1ba391b8d3b9a00dca541"><td class="memItemLeft" align="right" valign="top">task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a8a62642cb4b1ba391b8d3b9a00dca541">prepare_for_spawning</a> (task *t)</td></tr>
<tr class="memdesc:a8a62642cb4b1ba391b8d3b9a00dca541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if t is affinitized to another thread, and if so, bundles it as proxy.  <a href="#a8a62642cb4b1ba391b8d3b9a00dca541">More...</a><br /></td></tr>
<tr class="separator:a8a62642cb4b1ba391b8d3b9a00dca541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d3a75d44d62525c8b31c32917d242"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f7d3a75d44d62525c8b31c32917d242"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a7f7d3a75d44d62525c8b31c32917d242">commit_spawned_tasks</a> (size_t new_tail)</td></tr>
<tr class="memdesc:a7f7d3a75d44d62525c8b31c32917d242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes newly spawned tasks visible to thieves. <br /></td></tr>
<tr class="separator:a7f7d3a75d44d62525c8b31c32917d242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf34e6a9902af76bbbeab1fd3851df8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#aecf34e6a9902af76bbbeab1fd3851df8">commit_relocated_tasks</a> (size_t new_tail)</td></tr>
<tr class="memdesc:aecf34e6a9902af76bbbeab1fd3851df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes relocated tasks visible to thieves and releases the local task pool.  <a href="#aecf34e6a9902af76bbbeab1fd3851df8">More...</a><br /></td></tr>
<tr class="separator:aecf34e6a9902af76bbbeab1fd3851df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded85ba71063b16621ee006bdc32404a"><td class="memItemLeft" align="right" valign="top">task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#aded85ba71063b16621ee006bdc32404a">get_task</a> ()</td></tr>
<tr class="memdesc:aded85ba71063b16621ee006bdc32404a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a task from the local pool.  <a href="#aded85ba71063b16621ee006bdc32404a">More...</a><br /></td></tr>
<tr class="separator:aded85ba71063b16621ee006bdc32404a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3459e061761c342966531ea291f1c3"><td class="memItemLeft" align="right" valign="top">task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a3f3459e061761c342966531ea291f1c3">get_mailbox_task</a> ()</td></tr>
<tr class="memdesc:a3f3459e061761c342966531ea291f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to get a task from the mailbox.  <a href="#a3f3459e061761c342966531ea291f1c3">More...</a><br /></td></tr>
<tr class="separator:a3f3459e061761c342966531ea291f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab220458d93ee750e02a045c20ce5483d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab220458d93ee750e02a045c20ce5483d"></a>
task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#ab220458d93ee750e02a045c20ce5483d">steal_task</a> (<a class="el" href="structtbb_1_1internal_1_1arena__slot.html">arena_slot</a> &amp;victim_arena_slot)</td></tr>
<tr class="memdesc:ab220458d93ee750e02a045c20ce5483d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steal task from another scheduler's ready pool. <br /></td></tr>
<tr class="separator:ab220458d93ee750e02a045c20ce5483d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0460616fb84af745b12688927ff1bb7d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a0460616fb84af745b12688927ff1bb7d">prepare_task_pool</a> (size_t n)</td></tr>
<tr class="memdesc:a0460616fb84af745b12688927ff1bb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes sure that the task pool can accommodate at least n more elements.  <a href="#a0460616fb84af745b12688927ff1bb7d">More...</a><br /></td></tr>
<tr class="separator:a0460616fb84af745b12688927ff1bb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fce89a2413f0f02e05c048a0a148081"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fce89a2413f0f02e05c048a0a148081"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a4fce89a2413f0f02e05c048a0a148081">cleanup_master</a> ()</td></tr>
<tr class="memdesc:a4fce89a2413f0f02e05c048a0a148081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform necessary cleanup when a master thread stops using TBB. <br /></td></tr>
<tr class="separator:a4fce89a2413f0f02e05c048a0a148081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08edecb9bd9ef648bada9fb5b1febeec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08edecb9bd9ef648bada9fb5b1febeec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assert_task_pool_valid</b> () const </td></tr>
<tr class="separator:a08edecb9bd9ef648bada9fb5b1febeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a08aff3876258352d0042703abffeed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a08aff3876258352d0042703abffeed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spawn</b> (task &amp;first, task *&amp;next)</td></tr>
<tr class="separator:a1a08aff3876258352d0042703abffeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2396d7d9f7338d838e9ef3c9cad963e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2396d7d9f7338d838e9ef3c9cad963e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spawn_root_and_wait</b> (task &amp;first, task *&amp;next)</td></tr>
<tr class="separator:ab2396d7d9f7338d838e9ef3c9cad963e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdf48713a00843b7b51977c8ffc77a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cdf48713a00843b7b51977c8ffc77a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>enqueue</b> (task &amp;, void *reserved)</td></tr>
<tr class="separator:a6cdf48713a00843b7b51977c8ffc77a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abff4996f1d77c35f30aaa31b9d6084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a1abff4996f1d77c35f30aaa31b9d6084">local_spawn</a> (task &amp;first, task *&amp;next)</td></tr>
<tr class="separator:a1abff4996f1d77c35f30aaa31b9d6084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa976700664443eb85675f0eb91812400"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa976700664443eb85675f0eb91812400"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>local_spawn_root_and_wait</b> (task &amp;first, task *&amp;next)</td></tr>
<tr class="separator:aa976700664443eb85675f0eb91812400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509997dbb9b97ad2cca0a3af76c04e90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a509997dbb9b97ad2cca0a3af76c04e90"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>local_wait_for_all</b> (task &amp;parent, task *child)=0</td></tr>
<tr class="separator:a509997dbb9b97ad2cca0a3af76c04e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e6dd672693eb34cd6fd46ed7a7c6a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66e6dd672693eb34cd6fd46ed7a7c6a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a66e6dd672693eb34cd6fd46ed7a7c6a6">free_scheduler</a> ()</td></tr>
<tr class="memdesc:a66e6dd672693eb34cd6fd46ed7a7c6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and deallocate this scheduler object. <br /></td></tr>
<tr class="separator:a66e6dd672693eb34cd6fd46ed7a7c6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d316e9f3063c6b57fa21e0716d4d77"><td class="memItemLeft" align="right" valign="top">task &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#aa0d316e9f3063c6b57fa21e0716d4d77">allocate_task</a> (size_t number_of_bytes, __TBB_CONTEXT_ARG(task *parent, task_group_context *context))</td></tr>
<tr class="memdesc:aa0d316e9f3063c6b57fa21e0716d4d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate task object, either from the heap or a free list.  <a href="#aa0d316e9f3063c6b57fa21e0716d4d77">More...</a><br /></td></tr>
<tr class="separator:aa0d316e9f3063c6b57fa21e0716d4d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dd37171af77214add72a973e6b71ba"><td class="memTemplParams" colspan="2">template&lt;free_task_hint h&gt; </td></tr>
<tr class="memitem:a12dd37171af77214add72a973e6b71ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a12dd37171af77214add72a973e6b71ba">free_task</a> (task &amp;t)</td></tr>
<tr class="memdesc:a12dd37171af77214add72a973e6b71ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put task on free list.  <a href="#a12dd37171af77214add72a973e6b71ba">More...</a><br /></td></tr>
<tr class="separator:a12dd37171af77214add72a973e6b71ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad965858a5e7cb5574926d8d1692063b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad965858a5e7cb5574926d8d1692063b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#ad965858a5e7cb5574926d8d1692063b5">deallocate_task</a> (task &amp;t)</td></tr>
<tr class="memdesc:ad965858a5e7cb5574926d8d1692063b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return task object to the memory allocator. <br /></td></tr>
<tr class="separator:ad965858a5e7cb5574926d8d1692063b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64d15a434f12a7fbfd46910813ea59f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af64d15a434f12a7fbfd46910813ea59f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#af64d15a434f12a7fbfd46910813ea59f">is_worker</a> ()</td></tr>
<tr class="memdesc:af64d15a434f12a7fbfd46910813ea59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if running on a worker thread, false otherwise. <br /></td></tr>
<tr class="separator:af64d15a434f12a7fbfd46910813ea59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fe7450cc14ca226340cf8bffd379c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a84fe7450cc14ca226340cf8bffd379c7">master_outermost_level</a> () const </td></tr>
<tr class="memdesc:a84fe7450cc14ca226340cf8bffd379c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the scheduler is on the outermost dispatch level in a master thread.  <a href="#a84fe7450cc14ca226340cf8bffd379c7">More...</a><br /></td></tr>
<tr class="separator:a84fe7450cc14ca226340cf8bffd379c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7eff5365d63114c100e0a490e04884"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e7eff5365d63114c100e0a490e04884"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a4e7eff5365d63114c100e0a490e04884">worker_outermost_level</a> () const </td></tr>
<tr class="memdesc:a4e7eff5365d63114c100e0a490e04884"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the scheduler is on the outermost dispatch level in a worker thread. <br /></td></tr>
<tr class="separator:a4e7eff5365d63114c100e0a490e04884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75b9adc115cb49cde7aa4878a186d0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad75b9adc115cb49cde7aa4878a186d0a"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#ad75b9adc115cb49cde7aa4878a186d0a">number_of_workers_in_my_arena</a> ()</td></tr>
<tr class="memdesc:ad75b9adc115cb49cde7aa4878a186d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of worker threads in the arena this thread belongs to. <br /></td></tr>
<tr class="separator:ad75b9adc115cb49cde7aa4878a186d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11895552b22a769d2cd40b9e7c090d9b"><td class="memItemLeft" align="right" valign="top">virtual task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a11895552b22a769d2cd40b9e7c090d9b">receive_or_steal_task</a> (__TBB_atomic reference_count &amp;completion_ref_count)=0</td></tr>
<tr class="memdesc:a11895552b22a769d2cd40b9e7c090d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try getting a task from other threads (via mailbox, stealing, FIFO queue, orphans adoption).  <a href="#a11895552b22a769d2cd40b9e7c090d9b">More...</a><br /></td></tr>
<tr class="separator:a11895552b22a769d2cd40b9e7c090d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720c816c0253fe199e4583cd24090e9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a720c816c0253fe199e4583cd24090e9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a720c816c0253fe199e4583cd24090e9b">free_nonlocal_small_task</a> (task &amp;t)</td></tr>
<tr class="memdesc:a720c816c0253fe199e4583cd24090e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a small task t that that was allocated by a different scheduler. <br /></td></tr>
<tr class="separator:a720c816c0253fe199e4583cd24090e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a33519b4cf710f8c46129672f79fb6ec4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33519b4cf710f8c46129672f79fb6ec4"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_version_3_task</b> (task &amp;t)</td></tr>
<tr class="separator:a33519b4cf710f8c46129672f79fb6ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868812dd8d875a225a6f589fdbaafe54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a868812dd8d875a225a6f589fdbaafe54"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a868812dd8d875a225a6f589fdbaafe54">is_proxy</a> (const task &amp;t)</td></tr>
<tr class="memdesc:a868812dd8d875a225a6f589fdbaafe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if t is a <a class="el" href="structtbb_1_1internal_1_1task__proxy.html">task_proxy</a>. <br /></td></tr>
<tr class="separator:a868812dd8d875a225a6f589fdbaafe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b3f1a35f3e9042af02cbcc6a20d2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a579b3f1a35f3e9042af02cbcc6a20d2f"></a>
static <a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html">generic_scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a579b3f1a35f3e9042af02cbcc6a20d2f">create_master</a> (<a class="el" href="classtbb_1_1internal_1_1arena.html">arena</a> &amp;a)</td></tr>
<tr class="memdesc:a579b3f1a35f3e9042af02cbcc6a20d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a scheduler for a master thread. <br /></td></tr>
<tr class="separator:a579b3f1a35f3e9042af02cbcc6a20d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1108924834fb3c3e1bc0d2142bccb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec1108924834fb3c3e1bc0d2142bccb0"></a>
static <a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html">generic_scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#aec1108924834fb3c3e1bc0d2142bccb0">create_worker</a> (<a class="el" href="classtbb_1_1internal_1_1market.html">market</a> &amp;m, size_t index)</td></tr>
<tr class="memdesc:aec1108924834fb3c3e1bc0d2142bccb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a scheduler for a worker thread. <br /></td></tr>
<tr class="separator:aec1108924834fb3c3e1bc0d2142bccb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a0b659589202963562cbdb23465807"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6a0b659589202963562cbdb23465807"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#ae6a0b659589202963562cbdb23465807">cleanup_worker</a> (void *arg, bool worker)</td></tr>
<tr class="memdesc:ae6a0b659589202963562cbdb23465807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform necessary cleanup when a worker thread finishes. <br /></td></tr>
<tr class="separator:ae6a0b659589202963562cbdb23465807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb580929e3e34d6da1728e6fee8b6979"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb580929e3e34d6da1728e6fee8b6979"></a>
static task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#abb580929e3e34d6da1728e6fee8b6979">plugged_return_list</a> ()</td></tr>
<tr class="memdesc:abb580929e3e34d6da1728e6fee8b6979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special value used to mark my_return_list as not taking any more entries. <br /></td></tr>
<tr class="separator:abb580929e3e34d6da1728e6fee8b6979"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ade9f23ce97db8725a9c3718e76aa682d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade9f23ce97db8725a9c3718e76aa682d"></a>
uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#ade9f23ce97db8725a9c3718e76aa682d">my_stealing_threshold</a></td></tr>
<tr class="memdesc:ade9f23ce97db8725a9c3718e76aa682d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position in the call stack specifying its maximal filling when stealing is still allowed. <br /></td></tr>
<tr class="separator:ade9f23ce97db8725a9c3718e76aa682d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac652e4a610353888a31352e678955e1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac652e4a610353888a31352e678955e1b"></a>
<a class="el" href="classtbb_1_1internal_1_1market.html">market</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#ac652e4a610353888a31352e678955e1b">my_market</a></td></tr>
<tr class="memdesc:ac652e4a610353888a31352e678955e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The market I am in. <br /></td></tr>
<tr class="separator:ac652e4a610353888a31352e678955e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee56a8b51b71d3f96f9c8cacf00fe845"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee56a8b51b71d3f96f9c8cacf00fe845"></a>
<a class="el" href="classtbb_1_1internal_1_1FastRandom.html">FastRandom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#aee56a8b51b71d3f96f9c8cacf00fe845">my_random</a></td></tr>
<tr class="memdesc:aee56a8b51b71d3f96f9c8cacf00fe845"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRandom.html">Random</a> number generator used for picking a random victim from which to steal. <br /></td></tr>
<tr class="separator:aee56a8b51b71d3f96f9c8cacf00fe845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ed26dede8410a72f37bce24cb26239"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52ed26dede8410a72f37bce24cb26239"></a>
task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a52ed26dede8410a72f37bce24cb26239">my_free_list</a></td></tr>
<tr class="memdesc:a52ed26dede8410a72f37bce24cb26239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free list of small tasks that can be reused. <br /></td></tr>
<tr class="separator:a52ed26dede8410a72f37bce24cb26239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc495d5b077a2ef1b05e15e820555d90"><td class="memItemLeft" align="right" valign="top">task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#abc495d5b077a2ef1b05e15e820555d90">my_dummy_task</a></td></tr>
<tr class="memdesc:abc495d5b077a2ef1b05e15e820555d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fake root task created by slave threads.  <a href="#abc495d5b077a2ef1b05e15e820555d90">More...</a><br /></td></tr>
<tr class="separator:abc495d5b077a2ef1b05e15e820555d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf8d776a439320e1e001381cf5d4ad7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a8cf8d776a439320e1e001381cf5d4ad7">my_ref_count</a></td></tr>
<tr class="memdesc:a8cf8d776a439320e1e001381cf5d4ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference count for scheduler.  <a href="#a8cf8d776a439320e1e001381cf5d4ad7">More...</a><br /></td></tr>
<tr class="separator:a8cf8d776a439320e1e001381cf5d4ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5b021643394b6d3f743bea9cb5e2bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb5b021643394b6d3f743bea9cb5e2bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#afb5b021643394b6d3f743bea9cb5e2bd">my_auto_initialized</a></td></tr>
<tr class="memdesc:afb5b021643394b6d3f743bea9cb5e2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if *this was created by automatic TBB initialization. <br /></td></tr>
<tr class="separator:afb5b021643394b6d3f743bea9cb5e2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd421a07fae7a1c9e3fa49e005bb513"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bd421a07fae7a1c9e3fa49e005bb513"></a>
__TBB_atomic intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a4bd421a07fae7a1c9e3fa49e005bb513">my_small_task_count</a></td></tr>
<tr class="memdesc:a4bd421a07fae7a1c9e3fa49e005bb513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of small tasks that have been allocated by this scheduler. <br /></td></tr>
<tr class="separator:a4bd421a07fae7a1c9e3fa49e005bb513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5777a002f8b7b3a72cb7fc4a477fb29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5777a002f8b7b3a72cb7fc4a477fb29"></a>
task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#ab5777a002f8b7b3a72cb7fc4a477fb29">my_return_list</a></td></tr>
<tr class="memdesc:ab5777a002f8b7b3a72cb7fc4a477fb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of small tasks that have been returned to this scheduler by other schedulers. <br /></td></tr>
<tr class="separator:ab5777a002f8b7b3a72cb7fc4a477fb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_structtbb_1_1internal_1_1scheduler__state')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="structtbb_1_1internal_1_1scheduler__state.html">tbb::internal::scheduler_state</a></td></tr>
<tr class="memitem:a35aa72cfdda3b500e908925a3d6da747 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35aa72cfdda3b500e908925a3d6da747"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtbb_1_1internal_1_1scheduler__state.html#a35aa72cfdda3b500e908925a3d6da747">my_arena_index</a></td></tr>
<tr class="memdesc:a35aa72cfdda3b500e908925a3d6da747 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the arena slot the scheduler occupies now, or occupied last time. <br /></td></tr>
<tr class="separator:a35aa72cfdda3b500e908925a3d6da747 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2fdcecd347bf767e89fda580545c1a inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f2fdcecd347bf767e89fda580545c1a"></a>
<a class="el" href="structtbb_1_1internal_1_1arena__slot.html">arena_slot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtbb_1_1internal_1_1scheduler__state.html#a6f2fdcecd347bf767e89fda580545c1a">my_arena_slot</a></td></tr>
<tr class="memdesc:a6f2fdcecd347bf767e89fda580545c1a inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the slot in the arena we own at the moment. <br /></td></tr>
<tr class="separator:a6f2fdcecd347bf767e89fda580545c1a inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b830853cb0386a2b8744d4c7dff3a80 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b830853cb0386a2b8744d4c7dff3a80"></a>
<a class="el" href="classtbb_1_1internal_1_1arena.html">arena</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtbb_1_1internal_1_1scheduler__state.html#a6b830853cb0386a2b8744d4c7dff3a80">my_arena</a></td></tr>
<tr class="memdesc:a6b830853cb0386a2b8744d4c7dff3a80 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="mdescLeft">&#160;</td><td class="mdescRight">The arena that I own (if master) or am servicing at the moment (if worker) <br /></td></tr>
<tr class="separator:a6b830853cb0386a2b8744d4c7dff3a80 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9af4d8baddbbc2af433e11297be8a5 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac9af4d8baddbbc2af433e11297be8a5"></a>
task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtbb_1_1internal_1_1scheduler__state.html#aac9af4d8baddbbc2af433e11297be8a5">my_innermost_running_task</a></td></tr>
<tr class="memdesc:aac9af4d8baddbbc2af433e11297be8a5 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="mdescLeft">&#160;</td><td class="mdescRight">Innermost task whose task::execute() is running. <br /></td></tr>
<tr class="separator:aac9af4d8baddbbc2af433e11297be8a5 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d38ed67db424dde8e838e333b09a34 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memItemLeft" align="right" valign="top">task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtbb_1_1internal_1_1scheduler__state.html#a65d38ed67db424dde8e838e333b09a34">my_dispatching_task</a></td></tr>
<tr class="memdesc:a65d38ed67db424dde8e838e333b09a34 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task, in the context of which the current TBB dispatch loop is running.  <a href="#a65d38ed67db424dde8e838e333b09a34">More...</a><br /></td></tr>
<tr class="separator:a65d38ed67db424dde8e838e333b09a34 inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b120ea3121cd82f578eef2c1319f9fe inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b120ea3121cd82f578eef2c1319f9fe"></a>
<a class="el" href="classtbb_1_1internal_1_1mail__inbox.html">mail_inbox</a>&#160;</td><td class="memItemRight" valign="bottom"><b>my_inbox</b></td></tr>
<tr class="separator:a5b120ea3121cd82f578eef2c1319f9fe inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a635bad42d492013d4a06d1af0c452b inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memItemLeft" align="right" valign="top">affinity_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtbb_1_1internal_1_1scheduler__state.html#a3a635bad42d492013d4a06d1af0c452b">my_affinity_id</a></td></tr>
<tr class="memdesc:a3a635bad42d492013d4a06d1af0c452b inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mailbox id assigned to this scheduler.  <a href="#a3a635bad42d492013d4a06d1af0c452b">More...</a><br /></td></tr>
<tr class="separator:a3a635bad42d492013d4a06d1af0c452b inherit pub_attribs_structtbb_1_1internal_1_1scheduler__state"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:afbb75edc69c2ed1bcbf70098ca24a523"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbb75edc69c2ed1bcbf70098ca24a523"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#afbb75edc69c2ed1bcbf70098ca24a523">quick_task_size</a> = 256-task_prefix_reservation_size</td></tr>
<tr class="memdesc:afbb75edc69c2ed1bcbf70098ca24a523"><td class="mdescLeft">&#160;</td><td class="mdescRight">If sizeof(task) is &lt;=quick_task_size, it is handled on a free list instead of malloc'd. <br /></td></tr>
<tr class="separator:afbb75edc69c2ed1bcbf70098ca24a523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae85a4245c85c65c3cd51e63125f23e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afae85a4245c85c65c3cd51e63125f23e"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>null_arena_index</b> = ~size_t(0)</td></tr>
<tr class="separator:afae85a4245c85c65c3cd51e63125f23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1190ee0529a9280846bd50c4f50c8398"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a1190ee0529a9280846bd50c4f50c8398">min_task_pool_size</a> = 64</td></tr>
<tr class="separator:a1190ee0529a9280846bd50c4f50c8398"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6c2780fc1313fbd5c63c0ccee780d2e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c2780fc1313fbd5c63c0ccee780d2e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>generic_scheduler</b> (<a class="el" href="classtbb_1_1internal_1_1arena.html">arena</a> *, size_t index)</td></tr>
<tr class="separator:a6c2780fc1313fbd5c63c0ccee780d2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a276a67d14225fdfbb225cc85299850e3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a276a67d14225fdfbb225cc85299850e3"></a>
template&lt;typename SchedulerTraits &gt; </td></tr>
<tr class="memitem:a276a67d14225fdfbb225cc85299850e3"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>custom_scheduler</b></td></tr>
<tr class="separator:a276a67d14225fdfbb225cc85299850e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="structWork.html">Work</a> stealing task scheduler. </p>
<p>None of the fields here are ever read or written by threads other than the thread that creates the instance.</p>
<p>Class <a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html" title="Work stealing task scheduler. ">generic_scheduler</a> is an abstract base class that contains most of the scheduler, except for tweaks specific to processors and tools (e.g. VTune). The derived template class custom_scheduler&lt;SchedulerTraits&gt; fills in the tweaks. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6e2af1d0f7af34dee87a5b207d498f59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::internal::generic_scheduler::acquire_task_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the local task pool. </p>
<p>Garbles my_arena_slot-&gt;task_pool for the duration of the lock. Requires correctly set my_arena_slot-&gt;task_pool_ptr.</p>
<p>ATTENTION: This method is mostly the same as <a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a28bc27fa6c9a0cea424ced83b9f020ac" title="Locks victim&#39;s task pool, and returns pointer to it. The pointer can be NULL. ">generic_scheduler::lock_task_pool()</a>, with a little different logic of slot state checks (slot is either locked or points to our task pool). Thus if either of them is changed, consider changing the counterpart as well. </p>

</div>
</div>
<a class="anchor" id="aa0d316e9f3063c6b57fa21e0716d4d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">task &amp; tbb::internal::generic_scheduler::allocate_task </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__TBB_CONTEXT_ARG(task *parent, task_group_context *context)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate task object, either from the heap or a free list. </p>
<p>Returns uninitialized task object with initialized prefix. </p>

</div>
</div>
<a class="anchor" id="aecf34e6a9902af76bbbeab1fd3851df8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::internal::generic_scheduler::commit_relocated_tasks </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_tail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes relocated tasks visible to thieves and releases the local task pool. </p>
<p>Obviously, the task pool must be locked when calling this method. </p>

</div>
</div>
<a class="anchor" id="a28b7abb0919184fb3a19b3e865a11dcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::internal::generic_scheduler::enter_arena </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used by workers to enter the arena. </p>
<p>Does not lock the task pool in case if arena slot has been successfully grabbed. </p>

</div>
</div>
<a class="anchor" id="a12dd37171af77214add72a973e6b71ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;free_task_hint hint&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tbb::internal::generic_scheduler::free_task </td>
          <td>(</td>
          <td class="paramtype">task &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put task on free list. </p>
<p>Does not call destructor. </p>

</div>
</div>
<a class="anchor" id="a3f3459e061761c342966531ea291f1c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">task * tbb::internal::generic_scheduler::get_mailbox_task </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to get a task from the mailbox. </p>
<p>Gets a task only if it has not been executed by its sender or a thief that has stolen it from the sender's task pool. Otherwise returns NULL.</p>
<p>This method is intended to be used only by the thread extracting the proxy from its mailbox. (In contrast to local task pool, mailbox can be read only by its owner). </p>

</div>
</div>
<a class="anchor" id="aded85ba71063b16621ee006bdc32404a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task * tbb::internal::generic_scheduler::get_task </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a task from the local pool. </p>
<p>Called only by the pool owner. Returns the pointer to the task or NULL if the pool is empty. In the latter case compacts the pool. </p>

</div>
</div>
<a class="anchor" id="a2e07b903e093bff04e8d9de4fdbab70f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::internal::generic_scheduler::leave_arena </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave the arena. </p>
<p>Leaving arena automatically releases the task pool if it is locked. </p>

</div>
</div>
<a class="anchor" id="a1abff4996f1d77c35f30aaa31b9d6084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::internal::generic_scheduler::local_spawn </td>
          <td>(</td>
          <td class="paramtype">task &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">task *&amp;&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conceptually, this method should be a member of class scheduler. But doing so would force us to publish class scheduler in the headers. </p>

</div>
</div>
<a class="anchor" id="a28bc27fa6c9a0cea424ced83b9f020ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task ** tbb::internal::generic_scheduler::lock_task_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbb_1_1internal_1_1arena__slot.html">arena_slot</a> *&#160;</td>
          <td class="paramname"><em>victim_arena_slot</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks victim's task pool, and returns pointer to it. The pointer can be NULL. </p>
<p>Garbles victim_arena_slot-&gt;task_pool for the duration of the lock.</p>
<p>ATTENTION: This method is mostly the same as <a class="el" href="classtbb_1_1internal_1_1generic__scheduler.html#a6e2af1d0f7af34dee87a5b207d498f59" title="Locks the local task pool. ">generic_scheduler::acquire_task_pool()</a>, with a little different logic of slot state checks (slot can be empty, locked or point to any task pool other than ours, and asynchronous transitions between all these states are possible). Thus if any of them is changed, consider changing the counterpart as well </p>

</div>
</div>
<a class="anchor" id="a84fe7450cc14ca226340cf8bffd379c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::internal::generic_scheduler::master_outermost_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the scheduler is on the outermost dispatch level in a master thread. </p>
<p>Returns true when this scheduler instance is associated with an application thread, and is not executing any TBB task. This includes being in a TBB dispatch loop (one of wait_for_all methods) invoked directly from that thread. </p>

</div>
</div>
<a class="anchor" id="a8a62642cb4b1ba391b8d3b9a00dca541"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task * tbb::internal::generic_scheduler::prepare_for_spawning </td>
          <td>(</td>
          <td class="paramtype">task *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if t is affinitized to another thread, and if so, bundles it as proxy. </p>
<p>Returns either t or proxy containing t. </p>

</div>
</div>
<a class="anchor" id="a0460616fb84af745b12688927ff1bb7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tbb::internal::generic_scheduler::prepare_task_pool </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes sure that the task pool can accommodate at least n more elements. </p>
<p>If necessary relocates existing task pointers or grows the ready task deque. Returns (possible updated) tail index (not accounting for n). </p>

</div>
</div>
<a class="anchor" id="a11895552b22a769d2cd40b9e7c090d9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual task* tbb::internal::generic_scheduler::receive_or_steal_task </td>
          <td>(</td>
          <td class="paramtype">__TBB_atomic reference_count &amp;&#160;</td>
          <td class="paramname"><em>completion_ref_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try getting a task from other threads (via mailbox, stealing, FIFO queue, orphans adoption). </p>
<p>Returns obtained task or NULL if all attempts fail. </p>

<p>Implemented in <a class="el" href="classtbb_1_1internal_1_1custom__scheduler.html#a71b54b3854eb6961a7b09678450dd470">tbb::internal::custom_scheduler&lt; SchedulerTraits &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a24dd9ef31d1f73ea2fadcc35df6d9d21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::internal::generic_scheduler::release_task_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks the local task pool. </p>
<p>Restores my_arena_slot-&gt;task_pool munged by acquire_task_pool. Requires correctly set my_arena_slot-&gt;task_pool_ptr. </p>

</div>
</div>
<a class="anchor" id="ae28f8ec4bb8dab580d3452d58a84ebbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::internal::generic_scheduler::reset_deque_and_leave_arena </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>locked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets head and tail indices to 0, and leaves arena. </p>
<p>Argument specifies whether the task pool is currently locked by the owner (via acquire_task_pool). </p>

</div>
</div>
<a class="anchor" id="a5d6340b7bd950b0492e970ff62433198"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::internal::generic_scheduler::unlock_task_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbb_1_1internal_1_1arena__slot.html">arena_slot</a> *&#160;</td>
          <td class="paramname"><em>victim_arena_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">task **&#160;</td>
          <td class="paramname"><em>victim_task_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks victim's task pool. </p>
<p>Restores victim_arena_slot-&gt;task_pool munged by lock_task_pool. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a1190ee0529a9280846bd50c4f50c8398"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t tbb::internal::generic_scheduler::min_task_pool_size = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initial size of the task deque sufficient to serve without reallocation 4 nested parallel_for calls with iteration space of 65535 grains each. </p>

</div>
</div>
<a class="anchor" id="abc495d5b077a2ef1b05e15e820555d90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">task* tbb::internal::generic_scheduler::my_dummy_task</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fake root task created by slave threads. </p>
<p>The task is used as the "parent" argument to method wait_for_all. </p>

</div>
</div>
<a class="anchor" id="a8cf8d776a439320e1e001381cf5d4ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long tbb::internal::generic_scheduler::my_ref_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference count for scheduler. </p>
<p>Number of <a class="el" href="classtbb_1_1task__scheduler__init.html" title="Class delimiting the scope of task scheduler activity. ">task_scheduler_init</a> objects that point to this scheduler </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/pourya/Desktop/platform/repos/tetcutter/src/3rdparty/tbb/src/tbb/<a class="el" href="scheduler_8h_source.html">scheduler.h</a></li>
<li>/Users/pourya/Desktop/platform/repos/tetcutter/src/3rdparty/tbb/src/tbb/scheduler.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 16 2016 17:37:31 for tetcutter by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
