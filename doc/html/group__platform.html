<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>tetcutter: Platform interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tetcutter
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">High-Performance cutting tetrahedral meshes.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Platform interface</div>  </div>
</div><!--header-->
<div class="contents">

<p>The interface implemented by the platform-specific code.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaed0c9f6d4944cc993516fa1fe112101"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaaed0c9f6d4944cc993516fa1fe112101">_glfwPlatformInit</a> (void)</td></tr>
<tr class="memdesc:gaaed0c9f6d4944cc993516fa1fe112101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the platform-specific part of the library.  <a href="#gaaed0c9f6d4944cc993516fa1fe112101">More...</a><br /></td></tr>
<tr class="separator:gaaed0c9f6d4944cc993516fa1fe112101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a957eb71af07a553a88382f860a5fdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a957eb71af07a553a88382f860a5fdc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7a957eb71af07a553a88382f860a5fdc">_glfwPlatformTerminate</a> (void)</td></tr>
<tr class="memdesc:ga7a957eb71af07a553a88382f860a5fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the platform-specific part of the library. <br /></td></tr>
<tr class="separator:ga7a957eb71af07a553a88382f860a5fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cfd5b7d5ee93f3953056de86efc254c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4cfd5b7d5ee93f3953056de86efc254c">_glfwPlatformGetVersionString</a> (void)</td></tr>
<tr class="memdesc:ga4cfd5b7d5ee93f3953056de86efc254c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the compile-time configuration.  <a href="#ga4cfd5b7d5ee93f3953056de86efc254c">More...</a><br /></td></tr>
<tr class="separator:ga4cfd5b7d5ee93f3953056de86efc254c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5cf9708c6bae74f899eb62d29b7908a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gae5cf9708c6bae74f899eb62d29b7908a">_glfwPlatformGetCursorPos</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, double *xpos, double *ypos)</td></tr>
<tr class="memdesc:gae5cf9708c6bae74f899eb62d29b7908a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the position of the cursor relative to the client area of the window.  <a href="#gae5cf9708c6bae74f899eb62d29b7908a">More...</a><br /></td></tr>
<tr class="separator:gae5cf9708c6bae74f899eb62d29b7908a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga710177640b2ec4ca911527ff47348d18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga710177640b2ec4ca911527ff47348d18">_glfwPlatformSetCursorPos</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, double xpos, double ypos)</td></tr>
<tr class="memdesc:ga710177640b2ec4ca911527ff47348d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the cursor, relative to the client area of the window.  <a href="#ga710177640b2ec4ca911527ff47348d18">More...</a><br /></td></tr>
<tr class="separator:ga710177640b2ec4ca911527ff47348d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c2ffaf0606d63c62b99e1326befe79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga21c2ffaf0606d63c62b99e1326befe79">_glfwPlatformApplyCursorMode</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:ga21c2ffaf0606d63c62b99e1326befe79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the cursor mode of the specified window to the system.  <a href="#ga21c2ffaf0606d63c62b99e1326befe79">More...</a><br /></td></tr>
<tr class="separator:ga21c2ffaf0606d63c62b99e1326befe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e1120bde080e163979e037486ffa87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga13e1120bde080e163979e037486ffa87">_glfwPlatformGetMonitors</a> (int *count)</td></tr>
<tr class="memdesc:ga13e1120bde080e163979e037486ffa87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently connected monitors.  <a href="#ga13e1120bde080e163979e037486ffa87">More...</a><br /></td></tr>
<tr class="separator:ga13e1120bde080e163979e037486ffa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98093cf2b1d26ac6fe6bf1d101f46466"><td class="memItemLeft" align="right" valign="top">GLboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga98093cf2b1d26ac6fe6bf1d101f46466">_glfwPlatformIsSameMonitor</a> (<a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *first, <a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *second)</td></tr>
<tr class="memdesc:ga98093cf2b1d26ac6fe6bf1d101f46466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two monitor objects represent the same monitor.  <a href="#ga98093cf2b1d26ac6fe6bf1d101f46466">More...</a><br /></td></tr>
<tr class="separator:ga98093cf2b1d26ac6fe6bf1d101f46466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3047b94f0248b06b160f08992939796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gac3047b94f0248b06b160f08992939796">_glfwPlatformGetMonitorPos</a> (<a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *monitor, int *xpos, int *ypos)</td></tr>
<tr class="memdesc:gac3047b94f0248b06b160f08992939796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the monitor's viewport on the virtual screen.  <a href="#gac3047b94f0248b06b160f08992939796">More...</a><br /></td></tr>
<tr class="separator:gac3047b94f0248b06b160f08992939796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471526b59a2aa3ecc70bdf0163fa6a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGLFWvidmode.html">GLFWvidmode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga471526b59a2aa3ecc70bdf0163fa6a8c">_glfwPlatformGetVideoModes</a> (<a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *monitor, int *count)</td></tr>
<tr class="memdesc:ga471526b59a2aa3ecc70bdf0163fa6a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the available video modes for the specified monitor.  <a href="#ga471526b59a2aa3ecc70bdf0163fa6a8c">More...</a><br /></td></tr>
<tr class="separator:ga471526b59a2aa3ecc70bdf0163fa6a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8336e546a783459b673772b591ffacd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab8336e546a783459b673772b591ffacd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_glfwPlatformGetVideoMode</b> (<a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *monitor, <a class="el" href="structGLFWvidmode.html">GLFWvidmode</a> *mode)</td></tr>
<tr class="separator:gab8336e546a783459b673772b591ffacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b200c0ce0ac89e118ba1fe502c58c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8b200c0ce0ac89e118ba1fe502c58c81">_glfwPlatformGetGammaRamp</a> (<a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *monitor, <a class="el" href="structGLFWgammaramp.html">GLFWgammaramp</a> *ramp)</td></tr>
<tr class="memdesc:ga8b200c0ce0ac89e118ba1fe502c58c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current gamma ramp for the specified monitor.  <a href="#ga8b200c0ce0ac89e118ba1fe502c58c81">More...</a><br /></td></tr>
<tr class="separator:ga8b200c0ce0ac89e118ba1fe502c58c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcaf1fc34700bd62b558caccce3ab45b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gabcaf1fc34700bd62b558caccce3ab45b">_glfwPlatformSetGammaRamp</a> (<a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *monitor, const <a class="el" href="structGLFWgammaramp.html">GLFWgammaramp</a> *ramp)</td></tr>
<tr class="memdesc:gabcaf1fc34700bd62b558caccce3ab45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current gamma ramp for the specified monitor.  <a href="#gabcaf1fc34700bd62b558caccce3ab45b">More...</a><br /></td></tr>
<tr class="separator:gabcaf1fc34700bd62b558caccce3ab45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3b7b168b64bb1abbfc17e93d0c5014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gabf3b7b168b64bb1abbfc17e93d0c5014">_glfwPlatformSetClipboardString</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, const char *string)</td></tr>
<tr class="memdesc:gabf3b7b168b64bb1abbfc17e93d0c5014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the clipboard to the specified string.  <a href="#gabf3b7b168b64bb1abbfc17e93d0c5014">More...</a><br /></td></tr>
<tr class="separator:gabf3b7b168b64bb1abbfc17e93d0c5014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a498c1b06756ed10baed476e2b0ffc5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8a498c1b06756ed10baed476e2b0ffc5">_glfwPlatformGetClipboardString</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:ga8a498c1b06756ed10baed476e2b0ffc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of the clipboard as a string.  <a href="#ga8a498c1b06756ed10baed476e2b0ffc5">More...</a><br /></td></tr>
<tr class="separator:ga8a498c1b06756ed10baed476e2b0ffc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022d0cd34e122cef768f557c755fec9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga022d0cd34e122cef768f557c755fec9c">_glfwPlatformJoystickPresent</a> (int joy)</td></tr>
<tr class="memdesc:ga022d0cd34e122cef768f557c755fec9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the specified joystick is present.  <a href="#ga022d0cd34e122cef768f557c755fec9c">More...</a><br /></td></tr>
<tr class="separator:ga022d0cd34e122cef768f557c755fec9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a4d841bb3764d04f7ec9c7390de702"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga40a4d841bb3764d04f7ec9c7390de702">_glfwPlatformGetJoystickAxes</a> (int joy, int *count)</td></tr>
<tr class="memdesc:ga40a4d841bb3764d04f7ec9c7390de702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the values of all axes of the specified joystick.  <a href="#ga40a4d841bb3764d04f7ec9c7390de702">More...</a><br /></td></tr>
<tr class="separator:ga40a4d841bb3764d04f7ec9c7390de702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc09b5bd02e6f98873117ca6f86d0fe6"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gafc09b5bd02e6f98873117ca6f86d0fe6">_glfwPlatformGetJoystickButtons</a> (int joy, int *count)</td></tr>
<tr class="memdesc:gafc09b5bd02e6f98873117ca6f86d0fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state of all buttons of the specified joystick.  <a href="#gafc09b5bd02e6f98873117ca6f86d0fe6">More...</a><br /></td></tr>
<tr class="separator:gafc09b5bd02e6f98873117ca6f86d0fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e41c4ab4eeb7e437bbb9dce58b16f27"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2e41c4ab4eeb7e437bbb9dce58b16f27">_glfwPlatformGetJoystickName</a> (int joy)</td></tr>
<tr class="memdesc:ga2e41c4ab4eeb7e437bbb9dce58b16f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the specified joystick.  <a href="#ga2e41c4ab4eeb7e437bbb9dce58b16f27">More...</a><br /></td></tr>
<tr class="separator:ga2e41c4ab4eeb7e437bbb9dce58b16f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42528913973ea604994212d17d80a67b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga42528913973ea604994212d17d80a67b">_glfwPlatformGetTime</a> (void)</td></tr>
<tr class="memdesc:ga42528913973ea604994212d17d80a67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the GLFW timer.  <a href="#ga42528913973ea604994212d17d80a67b">More...</a><br /></td></tr>
<tr class="separator:ga42528913973ea604994212d17d80a67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec7765724b69e6e75a855e2363c298c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3ec7765724b69e6e75a855e2363c298c">_glfwPlatformSetTime</a> (double time)</td></tr>
<tr class="memdesc:ga3ec7765724b69e6e75a855e2363c298c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the GLFW timer.  <a href="#ga3ec7765724b69e6e75a855e2363c298c">More...</a><br /></td></tr>
<tr class="separator:ga3ec7765724b69e6e75a855e2363c298c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f9fd053009c1add7335c8ef4f94d4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad7f9fd053009c1add7335c8ef4f94d4f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_glfwPlatformCreateWindow</b> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, const <a class="el" href="struct__GLFWwndconfig.html">_GLFWwndconfig</a> *wndconfig, const <a class="el" href="struct__GLFWctxconfig.html">_GLFWctxconfig</a> *ctxconfig, const <a class="el" href="struct__GLFWfbconfig.html">_GLFWfbconfig</a> *fbconfig)</td></tr>
<tr class="separator:gad7f9fd053009c1add7335c8ef4f94d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f7ad4aa22c7f523ab39db732314119"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89f7ad4aa22c7f523ab39db732314119"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_glfwPlatformDestroyWindow</b> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="separator:ga89f7ad4aa22c7f523ab39db732314119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed22dd224adc359c8aee05e1f7ccd92b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaed22dd224adc359c8aee05e1f7ccd92b">_glfwPlatformSetWindowTitle</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, const char *title)</td></tr>
<tr class="memdesc:gaed22dd224adc359c8aee05e1f7ccd92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the title of the specified window.  <a href="#gaed22dd224adc359c8aee05e1f7ccd92b">More...</a><br /></td></tr>
<tr class="separator:gaed22dd224adc359c8aee05e1f7ccd92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1b18b535ef2d5619e3e1bd811a1abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga6b1b18b535ef2d5619e3e1bd811a1abf">_glfwPlatformGetWindowPos</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, int *xpos, int *ypos)</td></tr>
<tr class="memdesc:ga6b1b18b535ef2d5619e3e1bd811a1abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the position of the client area of the specified window.  <a href="#ga6b1b18b535ef2d5619e3e1bd811a1abf">More...</a><br /></td></tr>
<tr class="separator:ga6b1b18b535ef2d5619e3e1bd811a1abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0934dc13a91c13e63e4ad615c23be628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0934dc13a91c13e63e4ad615c23be628">_glfwPlatformSetWindowPos</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, int xpos, int ypos)</td></tr>
<tr class="memdesc:ga0934dc13a91c13e63e4ad615c23be628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the client area of the specified window.  <a href="#ga0934dc13a91c13e63e4ad615c23be628">More...</a><br /></td></tr>
<tr class="separator:ga0934dc13a91c13e63e4ad615c23be628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553e9df9260702f74ddb6e4e9ca43493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga553e9df9260702f74ddb6e4e9ca43493">_glfwPlatformGetWindowSize</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, int *width, int *height)</td></tr>
<tr class="memdesc:ga553e9df9260702f74ddb6e4e9ca43493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the size of the client area of the specified window.  <a href="#ga553e9df9260702f74ddb6e4e9ca43493">More...</a><br /></td></tr>
<tr class="separator:ga553e9df9260702f74ddb6e4e9ca43493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ba7669f18179be6e7df88f9891db89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga29ba7669f18179be6e7df88f9891db89">_glfwPlatformSetWindowSize</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, int width, int height)</td></tr>
<tr class="memdesc:ga29ba7669f18179be6e7df88f9891db89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the client area of the specified window.  <a href="#ga29ba7669f18179be6e7df88f9891db89">More...</a><br /></td></tr>
<tr class="separator:ga29ba7669f18179be6e7df88f9891db89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46182dc3273499b6cf8cb3deb7da2964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga46182dc3273499b6cf8cb3deb7da2964">_glfwPlatformGetFramebufferSize</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, int *width, int *height)</td></tr>
<tr class="memdesc:ga46182dc3273499b6cf8cb3deb7da2964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the size of the framebuffer of the specified window.  <a href="#ga46182dc3273499b6cf8cb3deb7da2964">More...</a><br /></td></tr>
<tr class="separator:ga46182dc3273499b6cf8cb3deb7da2964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dbdea593f2ce9dcc0c83bb5f318d598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga5dbdea593f2ce9dcc0c83bb5f318d598">_glfwPlatformGetWindowFrameSize</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, int *left, int *top, int *right, int *bottom)</td></tr>
<tr class="memdesc:ga5dbdea593f2ce9dcc0c83bb5f318d598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the size of the frame of the window.  <a href="#ga5dbdea593f2ce9dcc0c83bb5f318d598">More...</a><br /></td></tr>
<tr class="separator:ga5dbdea593f2ce9dcc0c83bb5f318d598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2573aaf669aa4467fd3273dc24630be2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2573aaf669aa4467fd3273dc24630be2">_glfwPlatformIconifyWindow</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:ga2573aaf669aa4467fd3273dc24630be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iconifies the specified window.  <a href="#ga2573aaf669aa4467fd3273dc24630be2">More...</a><br /></td></tr>
<tr class="separator:ga2573aaf669aa4467fd3273dc24630be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d70bc903e5c7b565bdb8fe795348c1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7d70bc903e5c7b565bdb8fe795348c1d">_glfwPlatformRestoreWindow</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:ga7d70bc903e5c7b565bdb8fe795348c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the specified window.  <a href="#ga7d70bc903e5c7b565bdb8fe795348c1d">More...</a><br /></td></tr>
<tr class="separator:ga7d70bc903e5c7b565bdb8fe795348c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4c51c7c430fab92aec7797734f44a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gabc4c51c7c430fab92aec7797734f44a7">_glfwPlatformShowWindow</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:gabc4c51c7c430fab92aec7797734f44a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the specified window visible.  <a href="#gabc4c51c7c430fab92aec7797734f44a7">More...</a><br /></td></tr>
<tr class="separator:gabc4c51c7c430fab92aec7797734f44a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4f24ce5024f55a1f89a6aac534589f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3c4f24ce5024f55a1f89a6aac534589f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_glfwPlatformUnhideWindow</b> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="separator:ga3c4f24ce5024f55a1f89a6aac534589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga903498be431ea21170c4ea1b80791204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga903498be431ea21170c4ea1b80791204">_glfwPlatformHideWindow</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:ga903498be431ea21170c4ea1b80791204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hides the specified window.  <a href="#ga903498be431ea21170c4ea1b80791204">More...</a><br /></td></tr>
<tr class="separator:ga903498be431ea21170c4ea1b80791204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac239b1980772ae5c5f1b1f683b1aa1ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac239b1980772ae5c5f1b1f683b1aa1ea"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gac239b1980772ae5c5f1b1f683b1aa1ea">_glfwPlatformWindowFocused</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:gac239b1980772ae5c5f1b1f683b1aa1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the window is focused. <br /></td></tr>
<tr class="separator:gac239b1980772ae5c5f1b1f683b1aa1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c55b62c3e61ce1e238fc339a712bc93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c55b62c3e61ce1e238fc339a712bc93"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1c55b62c3e61ce1e238fc339a712bc93">_glfwPlatformWindowIconified</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:ga1c55b62c3e61ce1e238fc339a712bc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the window is iconified. <br /></td></tr>
<tr class="separator:ga1c55b62c3e61ce1e238fc339a712bc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d6dcb902a778ac7a805172ac3955135"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d6dcb902a778ac7a805172ac3955135"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4d6dcb902a778ac7a805172ac3955135">_glfwPlatformWindowVisible</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:ga4d6dcb902a778ac7a805172ac3955135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the window is visible. <br /></td></tr>
<tr class="separator:ga4d6dcb902a778ac7a805172ac3955135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b129633a113e1d2bc159af038629dda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3b129633a113e1d2bc159af038629dda">_glfwPlatformPollEvents</a> (void)</td></tr>
<tr class="memdesc:ga3b129633a113e1d2bc159af038629dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes all pending events.  <a href="#ga3b129633a113e1d2bc159af038629dda">More...</a><br /></td></tr>
<tr class="separator:ga3b129633a113e1d2bc159af038629dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4fd289ab03927d5856d8eb69977b9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2d4fd289ab03927d5856d8eb69977b9a">_glfwPlatformWaitEvents</a> (void)</td></tr>
<tr class="memdesc:ga2d4fd289ab03927d5856d8eb69977b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until events are queued and processes them.  <a href="#ga2d4fd289ab03927d5856d8eb69977b9a">More...</a><br /></td></tr>
<tr class="separator:ga2d4fd289ab03927d5856d8eb69977b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac41dc1cf7dba6a7ce5f5903ffce9cf88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gac41dc1cf7dba6a7ce5f5903ffce9cf88">_glfwPlatformPostEmptyEvent</a> (void)</td></tr>
<tr class="memdesc:gac41dc1cf7dba6a7ce5f5903ffce9cf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an empty event to the event queue.  <a href="#gac41dc1cf7dba6a7ce5f5903ffce9cf88">More...</a><br /></td></tr>
<tr class="separator:gac41dc1cf7dba6a7ce5f5903ffce9cf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561ebc478ae1ed15b5551fafcdf3526a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga561ebc478ae1ed15b5551fafcdf3526a">_glfwPlatformMakeContextCurrent</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:ga561ebc478ae1ed15b5551fafcdf3526a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the context of the specified window current for the calling thread.  <a href="#ga561ebc478ae1ed15b5551fafcdf3526a">More...</a><br /></td></tr>
<tr class="separator:ga561ebc478ae1ed15b5551fafcdf3526a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5729dba637d75f8e80b477c01a609284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga5729dba637d75f8e80b477c01a609284">_glfwPlatformGetCurrentContext</a> (void)</td></tr>
<tr class="memdesc:ga5729dba637d75f8e80b477c01a609284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the window whose context is current on the calling thread.  <a href="#ga5729dba637d75f8e80b477c01a609284">More...</a><br /></td></tr>
<tr class="separator:ga5729dba637d75f8e80b477c01a609284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed52d436a3a5510e4bd252cbf5c76302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaed52d436a3a5510e4bd252cbf5c76302">_glfwPlatformSwapBuffers</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window)</td></tr>
<tr class="memdesc:gaed52d436a3a5510e4bd252cbf5c76302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the front and back buffers of the specified window.  <a href="#gaed52d436a3a5510e4bd252cbf5c76302">More...</a><br /></td></tr>
<tr class="separator:gaed52d436a3a5510e4bd252cbf5c76302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06af35966bc5ea06f59cae87aca6c075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga06af35966bc5ea06f59cae87aca6c075">_glfwPlatformSwapInterval</a> (int interval)</td></tr>
<tr class="memdesc:ga06af35966bc5ea06f59cae87aca6c075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the swap interval for the current context.  <a href="#ga06af35966bc5ea06f59cae87aca6c075">More...</a><br /></td></tr>
<tr class="separator:ga06af35966bc5ea06f59cae87aca6c075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3f2eb832d7f6b428d634051c9fd9c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga6d3f2eb832d7f6b428d634051c9fd9c3">_glfwPlatformExtensionSupported</a> (const char *extension)</td></tr>
<tr class="memdesc:ga6d3f2eb832d7f6b428d634051c9fd9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the specified extension is available.  <a href="#ga6d3f2eb832d7f6b428d634051c9fd9c3">More...</a><br /></td></tr>
<tr class="separator:ga6d3f2eb832d7f6b428d634051c9fd9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad7519aa101fae555c4bfe0f34f412a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__context.html#ga3d47c2d2fbe0be9c505d0e04e91a133c">GLFWglproc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaad7519aa101fae555c4bfe0f34f412a2">_glfwPlatformGetProcAddress</a> (const char *procname)</td></tr>
<tr class="memdesc:gaad7519aa101fae555c4bfe0f34f412a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the specified function for the current context.  <a href="#gaad7519aa101fae555c4bfe0f34f412a2">More...</a><br /></td></tr>
<tr class="separator:gaad7519aa101fae555c4bfe0f34f412a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c3eff1120388b2e8cbfe1579518a42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga38c3eff1120388b2e8cbfe1579518a42">_glfwPlatformCreateCursor</a> (<a class="el" href="struct__GLFWcursor.html">_GLFWcursor</a> *cursor, const <a class="el" href="structGLFWimage.html">GLFWimage</a> *image, int xhot, int yhot)</td></tr>
<tr class="memdesc:ga38c3eff1120388b2e8cbfe1579518a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a custom cursor.  <a href="#ga38c3eff1120388b2e8cbfe1579518a42">More...</a><br /></td></tr>
<tr class="separator:ga38c3eff1120388b2e8cbfe1579518a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc56a6e4f2450bc5e3abf681ccdf9b9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gacc56a6e4f2450bc5e3abf681ccdf9b9e">_glfwPlatformCreateStandardCursor</a> (<a class="el" href="struct__GLFWcursor.html">_GLFWcursor</a> *cursor, int shape)</td></tr>
<tr class="memdesc:gacc56a6e4f2450bc5e3abf681ccdf9b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a cursor with a standard shape.  <a href="#gacc56a6e4f2450bc5e3abf681ccdf9b9e">More...</a><br /></td></tr>
<tr class="separator:gacc56a6e4f2450bc5e3abf681ccdf9b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7505834ffe07386df151a191ce4677b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7505834ffe07386df151a191ce4677b9">_glfwPlatformDestroyCursor</a> (<a class="el" href="struct__GLFWcursor.html">_GLFWcursor</a> *cursor)</td></tr>
<tr class="memdesc:ga7505834ffe07386df151a191ce4677b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a cursor.  <a href="#ga7505834ffe07386df151a191ce4677b9">More...</a><br /></td></tr>
<tr class="separator:ga7505834ffe07386df151a191ce4677b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52276580374c999cf4babdd49270afa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga52276580374c999cf4babdd49270afa9">_glfwPlatformSetCursor</a> (<a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *window, <a class="el" href="struct__GLFWcursor.html">_GLFWcursor</a> *cursor)</td></tr>
<tr class="memdesc:ga52276580374c999cf4babdd49270afa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the cursor for the window.  <a href="#ga52276580374c999cf4babdd49270afa9">More...</a><br /></td></tr>
<tr class="separator:ga52276580374c999cf4babdd49270afa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The interface implemented by the platform-specific code. </p>
<p>The platform API is the interface exposed by the platform-specific code for each platform and is called by the shared code of the public API It mirrors the public API except it uses objects instead of handles. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga21c2ffaf0606d63c62b99e1326befe79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformApplyCursorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the cursor mode of the specified window to the system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window whose cursor mode to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga38c3eff1120388b2e8cbfe1579518a42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _glfwPlatformCreateCursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWcursor.html">_GLFWcursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGLFWimage.html">GLFWimage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xhot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yhot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a custom cursor. </p>
<p>Creates a new custom cursor image that can be set for a window with <a class="el" href="group__input.html#gafaf103cea2f43530cff7de4e01126a4f">glfwSetCursor</a>. The cursor can be destroyed with <a class="el" href="group__input.html#ga27556b7122117bc1bbb4bb3cc003ea43">glfwDestroyCursor</a>. Any remaining cursors are destroyed by <a class="el" href="group__init.html#gafd90e6fd4819ea9e22e5e739519a6504">glfwTerminate</a>.</p>
<p>The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight bits per channel. They are arranged canonically as packed sequential rows, starting from the top-left corner.</p>
<p>The cursor hotspot is specified in pixels, relative to the upper-left corner of the cursor image. Like all other coordinate systems in GLFW, the X-axis points to the right and the Y-axis points down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The desired cursor image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xhot</td><td>The desired x-coordinate, in pixels, of the cursor hotspot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yhot</td><td>The desired y-coordinate, in pixels, of the cursor hotspot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The handle of the created cursor, or <code>NULL</code> if an error occurred.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The specified image data is copied before this function returns.</dd></dl>
<dl class="section user"><dt>Reentrancy</dt><dd>This function may not be called from a callback.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cursor_object </dd>
<dd>
<a class="el" href="group__input.html#ga27556b7122117bc1bbb4bb3cc003ea43" title="Destroys a cursor. ">glfwDestroyCursor</a> </dd>
<dd>
<a class="el" href="group__input.html#ga969dd87ad2ddbf3e1086cc40f235eed1" title="Creates a cursor with a standard shape. ">glfwCreateStandardCursor</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.1. </dd></dl>

</div>
</div>
<a class="anchor" id="gacc56a6e4f2450bc5e3abf681ccdf9b9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _glfwPlatformCreateStandardCursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWcursor.html">_GLFWcursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a cursor with a standard shape. </p>
<p>Returns a cursor with a <a class="el" href="group__shapes.html">standard shape</a>, that can be set for a window with <a class="el" href="group__input.html#gafaf103cea2f43530cff7de4e01126a4f">glfwSetCursor</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>One of the <a class="el" href="group__shapes.html">standard shapes</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new cursor ready to use or <code>NULL</code> if an error occurred.</dd></dl>
<dl class="section user"><dt>Reentrancy</dt><dd>This function may not be called from a callback.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cursor_object </dd>
<dd>
<a class="el" href="group__input.html#gac0f0f691f2d110f9acfb4bfe07f1216c" title="Creates a custom cursor. ">glfwCreateCursor</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7505834ffe07386df151a191ce4677b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformDestroyCursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWcursor.html">_GLFWcursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a cursor. </p>
<p>This function destroys a cursor previously created with <a class="el" href="group__input.html#gac0f0f691f2d110f9acfb4bfe07f1216c">glfwCreateCursor</a>. Any remaining cursors will be destroyed by <a class="el" href="group__init.html#gafd90e6fd4819ea9e22e5e739519a6504">glfwTerminate</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cursor</td><td>The cursor object to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Reentrancy</dt><dd>This function may not be called from a callback.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cursor_object </dd>
<dd>
<a class="el" href="group__input.html#gac0f0f691f2d110f9acfb4bfe07f1216c" title="Creates a custom cursor. ">glfwCreateCursor</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d3f2eb832d7f6b428d634051c9fd9c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _glfwPlatformExtensionSupported </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the specified extension is available. </p>
<p>This function returns whether the specified client API extension is supported by the current OpenGL or OpenGL ES context. It searches both for OpenGL and OpenGL ES extension and platform-specific context creation API extensions.</p>
<p><a class="el" href="structA.html">A</a> context must be current on the calling thread. Calling this function without a current context will cause a <a class="el" href="group__errors.html#gaa8290386e9528ccb9e42a3a4e16fc0d0">GLFW_NO_CURRENT_CONTEXT</a> error.</p>
<p>As this functions retrieves and searches one or more extension strings each call, it is recommended that you cache its results if it is going to be used frequently. The extension strings will not change during the lifetime of a context, so there is no danger in doing this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extension</td><td>The ASCII encoded name of the extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GL_TRUE</code> if the extension is available, or <code>GL_FALSE</code> otherwise.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may be called from any thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>context_glext </dd>
<dd>
<a class="el" href="group__context.html#ga0e8af175218929615c16e74938c10f2a" title="Returns the address of the specified function for the current context. ">glfwGetProcAddress</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a498c1b06756ed10baed476e2b0ffc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* _glfwPlatformGetClipboardString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of the clipboard as a string. </p>
<p>This function returns the contents of the system clipboard, if it contains or is convertible to a UTF-8 encoded string. If the clipboard is empty or if its contents cannot be converted, <code>NULL</code> is returned and a <a class="el" href="group__errors.html#ga196e125ef261d94184e2b55c05762f14">GLFW_FORMAT_UNAVAILABLE</a> error is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window that will request the clipboard contents. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the clipboard as a UTF-8 encoded string, or <code>NULL</code> if an error occurred.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The returned string is allocated and freed by GLFW. You should not free it yourself. It is valid until the next call to <a class="el" href="group__input.html#ga3ac90c8bbaf0b46063bb02b574f3b6f7">glfwGetClipboardString</a> or <a class="el" href="group__input.html#ga7a580309bbc185a0459c3559021d2fd7">glfwSetClipboardString</a>, or until the library is terminated.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>clipboard </dd>
<dd>
<a class="el" href="group__input.html#ga7a580309bbc185a0459c3559021d2fd7" title="Sets the clipboard to the specified string. ">glfwSetClipboardString</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned string must be valid until the next call to <a class="el" href="group__platform.html#ga8a498c1b06756ed10baed476e2b0ffc5">_glfwPlatformGetClipboardString</a> or <a class="el" href="group__platform.html#gabf3b7b168b64bb1abbfc17e93d0c5014">_glfwPlatformSetClipboardString</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5729dba637d75f8e80b477c01a609284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a>* _glfwPlatformGetCurrentContext </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the window whose context is current on the calling thread. </p>
<p>This function returns the window whose OpenGL or OpenGL ES context is current on the calling thread.</p>
<dl class="section return"><dt>Returns</dt><dd>The window whose context is current, or <code>NULL</code> if no window's context is current.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may be called from any thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>context_current </dd>
<dd>
<a class="el" href="group__context.html#gafd76c93e15ec8b0b90506a9936a46185" title="Makes the context of the specified window current for the calling thread. ">glfwMakeContextCurrent</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="gae5cf9708c6bae74f899eb62d29b7908a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformGetCursorPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>xpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ypos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the position of the cursor relative to the client area of the window. </p>
<p>This function returns the position of the cursor, in screen coordinates, relative to the upper-left corner of the client area of the specified window.</p>
<p>If the cursor is disabled (with <code>GLFW_CURSOR_DISABLED</code>) then the cursor position is unbounded and limited only by the minimum and maximum values of a <code>double</code>.</p>
<p>The coordinate can be converted to their integer equivalents with the <code>floor</code> function. Casting directly to an integer type works for positive coordinates, but fails for negative ones.</p>
<p>Any or all of the position arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> position arguments will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The desired window. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpos</td><td>Where to store the cursor x-coordinate, relative to the left edge of the client area, or <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ypos</td><td>Where to store the cursor y-coordinate, relative to the to top edge of the client area, or <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cursor_pos </dd>
<dd>
<a class="el" href="group__input.html#gaaf152cc93418acb0ba342e3f4af922bc" title="Sets the position of the cursor, relative to the client area of the window. ">glfwSetCursorPos</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. Replaces <code>glfwGetMousePos</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46182dc3273499b6cf8cb3deb7da2964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformGetFramebufferSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the size of the framebuffer of the specified window. </p>
<p>This function retrieves the size, in pixels, of the framebuffer of the specified window. If you wish to retrieve the size of the window in screen coordinates, see <a class="el" href="group__window.html#ga7feb769ebb3f3d21579b5a3fb07be76e">glfwGetWindowSize</a>.</p>
<p>Any or all of the size arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> size arguments will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window whose framebuffer to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">width</td><td>Where to store the width, in pixels, of the framebuffer, or <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>Where to store the height, in pixels, of the framebuffer, or <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_fbsize </dd>
<dd>
<a class="el" href="group__window.html#gad766bcdb4465f9c6c62e5d8ca7cfba56" title="Sets the framebuffer resize callback for the specified window. ">glfwSetFramebufferSizeCallback</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b200c0ce0ac89e118ba1fe502c58c81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformGetGammaRamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGLFWgammaramp.html">GLFWgammaramp</a> *&#160;</td>
          <td class="paramname"><em>ramp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current gamma ramp for the specified monitor. </p>
<p>This function returns the current gamma ramp of the specified monitor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">monitor</td><td>The monitor to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current gamma ramp, or <code>NULL</code> if an error occurred.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The returned structure and its arrays are allocated and freed by GLFW. You should not free them yourself. They are valid until the specified monitor is disconnected, this function is called again for that monitor or the library is terminated.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>monitor_gamma</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga40a4d841bb3764d04f7ec9c7390de702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float* _glfwPlatformGetJoystickAxes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>joy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the values of all axes of the specified joystick. </p>
<p>This function returns the values of all axes of the specified joystick. Each element in the array is a value between -1.0 and 1.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joy</td><td>The <a class="el" href="group__joysticks.html">joystick</a> to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Where to store the number of axis values in the returned array. This is set to zero if an error occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of axis values, or <code>NULL</code> if the joystick is not present.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The returned array is allocated and freed by GLFW. You should not free it yourself. It is valid until the specified joystick is disconnected, this function is called again for that joystick or the library is terminated.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>joystick_axis</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. Replaces <code>glfwGetJoystickPos</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc09b5bd02e6f98873117ca6f86d0fe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* _glfwPlatformGetJoystickButtons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>joy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the state of all buttons of the specified joystick. </p>
<p>This function returns the state of all buttons of the specified joystick. Each element in the array is either <code>GLFW_PRESS</code> or <code>GLFW_RELEASE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joy</td><td>The <a class="el" href="group__joysticks.html">joystick</a> to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Where to store the number of button states in the returned array. This is set to zero if an error occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of button states, or <code>NULL</code> if the joystick is not present.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The returned array is allocated and freed by GLFW. You should not free it yourself. It is valid until the specified joystick is disconnected, this function is called again for that joystick or the library is terminated.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>joystick_button</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 2.2.</dd></dl>
<dl class="section user"><dt></dt><dd><b>GLFW 3:</b> Changed to return a dynamic array. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e41c4ab4eeb7e437bbb9dce58b16f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* _glfwPlatformGetJoystickName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>joy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the specified joystick. </p>
<p>This function returns the name, encoded as UTF-8, of the specified joystick. The returned string is allocated and freed by GLFW. You should not free it yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joy</td><td>The <a class="el" href="group__joysticks.html">joystick</a> to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The UTF-8 encoded name of the joystick, or <code>NULL</code> if the joystick is not present.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The returned string is allocated and freed by GLFW. You should not free it yourself. It is valid until the specified joystick is disconnected, this function is called again for that joystick or the library is terminated.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>joystick_name</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="gac3047b94f0248b06b160f08992939796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformGetMonitorPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ypos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position of the monitor's viewport on the virtual screen. </p>
<p>This function returns the position, in screen coordinates, of the upper-left corner of the specified monitor.</p>
<p>Any or all of the position arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> position arguments will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">monitor</td><td>The monitor to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpos</td><td>Where to store the monitor x-coordinate, or <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ypos</td><td>Where to store the monitor y-coordinate, or <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>monitor_properties</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13e1120bde080e163979e037486ffa87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a>** _glfwPlatformGetMonitors </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the currently connected monitors. </p>
<p>This function returns an array of handles for all currently connected monitors. The primary monitor is always first in the returned array. If no monitors were found, this function returns <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Where to store the number of monitors in the returned array. This is set to zero if an error occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of monitor handles, or <code>NULL</code> if no monitors were found or if an error occurred.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The returned array is allocated and freed by GLFW. You should not free it yourself. It is guaranteed to be valid only until the monitor configuration changes or the library is terminated.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>monitor_monitors </dd>
<dd>
monitor_event </dd>
<dd>
<a class="el" href="group__monitor.html#ga59ea49f377fe701dd76764183e64d9f4" title="Returns the primary monitor. ">glfwGetPrimaryMonitor</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="gaad7519aa101fae555c4bfe0f34f412a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__context.html#ga3d47c2d2fbe0be9c505d0e04e91a133c">GLFWglproc</a> _glfwPlatformGetProcAddress </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>procname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the address of the specified function for the current context. </p>
<p>This function returns the address of the specified core or extension function, if it is supported by the current context.</p>
<p><a class="el" href="structA.html">A</a> context must be current on the calling thread. Calling this function without a current context will cause a <a class="el" href="group__errors.html#gaa8290386e9528ccb9e42a3a4e16fc0d0">GLFW_NO_CURRENT_CONTEXT</a> error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">procname</td><td>The ASCII encoded name of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the function, or <code>NULL</code> if an [error](error_handling) occurred.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The address of a given function is not guaranteed to be the same between contexts.</dd>
<dd>
This function may return a non-<code>NULL</code> address despite the associated version or extension not being available. Always check the context version or extension string first.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The returned function pointer is valid until the context is destroyed or the library is terminated.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may be called from any thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>context_glext </dd>
<dd>
<a class="el" href="group__context.html#ga9a28c712d35f9e43534e1d03b051c04c" title="Returns whether the specified extension is available. ">glfwExtensionSupported</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga42528913973ea604994212d17d80a67b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double _glfwPlatformGetTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the GLFW timer. </p>
<p>This function returns the value of the GLFW timer. Unless the timer has been set using <a class="el" href="group__input.html#ga94360a3628a09f32708f83cc3fa48590">glfwSetTime</a>, the timer measures time elapsed since GLFW was initialized.</p>
<p>The resolution of the timer is system dependent, but is usually on the order of a few micro- or nanoseconds. It uses the highest-resolution monotonic time source on each supported platform.</p>
<dl class="section return"><dt>Returns</dt><dd>The current value, in seconds, or zero if an error occurred.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may be called from any thread. Access is not synchronized.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>time</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4cfd5b7d5ee93f3953056de86efc254c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* _glfwPlatformGetVersionString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string describing the compile-time configuration. </p>
<p>This function returns the compile-time generated version string of the GLFW library binary. It describes the version, platform, compiler and any platform-specific compile-time options.</p>
<p><b>Do not use the version string</b> to parse the GLFW library version. The <a class="el" href="group__init.html#ga2402c7824ac0194c13722790ff9559ff">glfwGetVersion</a> function already provides the version of the running library binary.</p>
<p>This function always succeeds.</p>
<dl class="section return"><dt>Returns</dt><dd>The GLFW version string.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called before <a class="el" href="group__init.html#gab41771f0215a2e0afb4cf1cf98082d40">glfwInit</a>.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The returned string is static and compile-time generated.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may be called from any thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>intro_version </dd>
<dd>
<a class="el" href="group__init.html#ga2402c7824ac0194c13722790ff9559ff" title="Retrieves the version of the GLFW library. ">glfwGetVersion</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned string must be available for the duration of the program.</dd>
<dd>
The returned string must not change for the duration of the program. </dd></dl>

</div>
</div>
<a class="anchor" id="ga471526b59a2aa3ecc70bdf0163fa6a8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGLFWvidmode.html">GLFWvidmode</a>* _glfwPlatformGetVideoModes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the available video modes for the specified monitor. </p>
<p>This function returns an array of all video modes supported by the specified monitor. The returned array is sorted in ascending order, first by color bit depth (the sum of all channel depths) and then by resolution area (the product of width and height).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">monitor</td><td>The monitor to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Where to store the number of video modes in the returned array. This is set to zero if an error occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of video modes, or <code>NULL</code> if an error occurred.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The returned array is allocated and freed by GLFW. You should not free it yourself. It is valid until the specified monitor is disconnected, this function is called again for that monitor or the library is terminated.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>monitor_modes </dd>
<dd>
<a class="el" href="group__monitor.html#gac234b63ec525c70d7e18ac84aca088c6" title="Returns the current mode of the specified monitor. ">glfwGetVideoMode</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0.</dd></dl>
<dl class="section user"><dt></dt><dd><b>GLFW 3:</b> Changed to return an array of modes for a specific monitor. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dbdea593f2ce9dcc0c83bb5f318d598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformGetWindowFrameSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the size of the frame of the window. </p>
<p>This function retrieves the size, in screen coordinates, of each edge of the frame of the specified window. This size includes the title bar, if the window has one. The size of the frame may vary depending on the window-related hints used to create it.</p>
<p>Because this function retrieves the size of each window frame edge and not the offset along a particular coordinate axis, the retrieved values will always be zero or positive.</p>
<p>Any or all of the size arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> size arguments will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window whose frame size to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left</td><td>Where to store the size, in screen coordinates, of the left edge of the window frame, or <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">top</td><td>Where to store the size, in screen coordinates, of the top edge of the window frame, or <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">right</td><td>Where to store the size, in screen coordinates, of the right edge of the window frame, or <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bottom</td><td>Where to store the size, in screen coordinates, of the bottom edge of the window frame, or <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_size</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b1b18b535ef2d5619e3e1bd811a1abf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformGetWindowPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ypos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the position of the client area of the specified window. </p>
<p>This function retrieves the position, in screen coordinates, of the upper-left corner of the client area of the specified window.</p>
<p>Any or all of the position arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> position arguments will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpos</td><td>Where to store the x-coordinate of the upper-left corner of the client area, or <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ypos</td><td>Where to store the y-coordinate of the upper-left corner of the client area, or <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_pos </dd>
<dd>
<a class="el" href="group__window.html#ga0dc8d880a0d87be16d3ea8114561f6f0" title="Sets the position of the client area of the specified window. ">glfwSetWindowPos</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga553e9df9260702f74ddb6e4e9ca43493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformGetWindowSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the size of the client area of the specified window. </p>
<p>This function retrieves the size, in screen coordinates, of the client area of the specified window. If you wish to retrieve the size of the framebuffer of the window in pixels, see <a class="el" href="group__window.html#gaf7d17f3534b4b6dc9a6f905e3a240b7e">glfwGetFramebufferSize</a>.</p>
<p>Any or all of the size arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> size arguments will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window whose size to retrieve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">width</td><td>Where to store the width, in screen coordinates, of the client area, or <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>Where to store the height, in screen coordinates, of the client area, or <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_size </dd>
<dd>
<a class="el" href="group__window.html#gae54d1f4915ded15e267ddd3f41496cd2" title="Sets the size of the client area of the specified window. ">glfwSetWindowSize</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0.</dd></dl>
<dl class="section user"><dt></dt><dd><b>GLFW 3:</b> Added window handle parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga903498be431ea21170c4ea1b80791204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformHideWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hides the specified window. </p>
<p>This function hides the specified window if it was previously visible. If the window is already hidden or is in full screen mode, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window to hide.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_hide </dd>
<dd>
<a class="el" href="group__window.html#ga7945bcdff9e5e058cf36505d6873ed8c" title="Makes the specified window visible. ">glfwShowWindow</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2573aaf669aa4467fd3273dc24630be2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformIconifyWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iconifies the specified window. </p>
<p>This function iconifies (minimizes) the specified window if it was previously restored. If the window is already iconified, this function does nothing.</p>
<p>If the specified window is a full screen window, the original monitor resolution is restored until the window is restored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window to iconify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_iconify </dd>
<dd>
<a class="el" href="group__window.html#ga1e29caf0b819f578b04db52fff17256c" title="Restores the specified window. ">glfwRestoreWindow</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 2.1.</dd></dl>
<dl class="section user"><dt></dt><dd><b>GLFW 3:</b> Added window handle parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaed0c9f6d4944cc993516fa1fe112101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _glfwPlatformInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the platform-specific part of the library. </p>
<dl class="section return"><dt>Returns</dt><dd><code>GL_TRUE</code> if successful, or <code>GL_FALSE</code> if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ga98093cf2b1d26ac6fe6bf1d101f46466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLboolean _glfwPlatformIsSameMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether two monitor objects represent the same monitor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first monitor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>The second monitor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GL_TRUE</code> if the monitor objects represent the same monitor, or <code>GL_FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga022d0cd34e122cef768f557c755fec9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _glfwPlatformJoystickPresent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>joy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the specified joystick is present. </p>
<p>This function returns whether the specified joystick is present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joy</td><td>The <a class="el" href="group__joysticks.html">joystick</a> to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GL_TRUE</code> if the joystick is present, or <code>GL_FALSE</code> otherwise.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>joystick</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. Replaces <code>glfwGetJoystickParam</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga561ebc478ae1ed15b5551fafcdf3526a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformMakeContextCurrent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the context of the specified window current for the calling thread. </p>
<p>This function makes the OpenGL or OpenGL ES context of the specified window current on the calling thread. <a class="el" href="structA.html">A</a> context can only be made current on a single thread at a time and each thread can have only a single current context at a time.</p>
<p>By default, making a context non-current implicitly forces a pipeline flush. On machines that support <code>GL_KHR_context_flush_control</code>, you can control whether a context performs this flush by setting the GLFW_CONTEXT_RELEASE_BEHAVIOR window hint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window whose context to make current, or <code>NULL</code> to detach the current context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may be called from any thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>context_current </dd>
<dd>
<a class="el" href="group__context.html#gac28d98c655377d81a516bf5ef90780c8" title="Returns the window whose context is current on the calling thread. ">glfwGetCurrentContext</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b129633a113e1d2bc159af038629dda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformPollEvents </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes all pending events. </p>
<p>This function processes only those events that are already in the event queue and then returns immediately. Processing events will cause the window and input callbacks associated with those events to be called.</p>
<p>On some platforms, a window move, resize or menu operation will cause event processing to block. This is due to how event processing is designed on those platforms. You can use the window refresh callback to redraw the contents of your window when necessary during such operations.</p>
<p>On some platforms, certain events are sent directly to the application without going through the event queue, causing callbacks to be called outside of a call to one of the event processing functions.</p>
<p>Event processing is not required for joystick input to work.</p>
<dl class="section user"><dt>Reentrancy</dt><dd>This function may not be called from a callback.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>events </dd>
<dd>
<a class="el" href="group__window.html#ga6e042d05823c11e11c7339b81a237738" title="Waits until events are queued and processes them. ">glfwWaitEvents</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0. </dd></dl>

</div>
</div>
<a class="anchor" id="gac41dc1cf7dba6a7ce5f5903ffce9cf88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformPostEmptyEvent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts an empty event to the event queue. </p>
<p>This function posts an empty event from the current thread to the event queue, causing <a class="el" href="group__window.html#ga6e042d05823c11e11c7339b81a237738">glfwWaitEvents</a> to return.</p>
<p>If no windows exist, this function returns immediately. For synchronization of threads in applications that do not create windows, use your threading library of choice.</p>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may be called from any thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>events </dd>
<dd>
<a class="el" href="group__window.html#ga6e042d05823c11e11c7339b81a237738" title="Waits until events are queued and processes them. ">glfwWaitEvents</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d70bc903e5c7b565bdb8fe795348c1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformRestoreWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the specified window. </p>
<p>This function restores the specified window if it was previously iconified (minimized). If the window is already restored, this function does nothing.</p>
<p>If the specified window is a full screen window, the resolution chosen for the window is restored on the selected monitor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window to restore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_iconify </dd>
<dd>
<a class="el" href="group__window.html#ga24274e3c6ecd44e11fec5e6b66e4d7f3" title="Iconifies the specified window. ">glfwIconifyWindow</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 2.1.</dd></dl>
<dl class="section user"><dt></dt><dd><b>GLFW 3:</b> Added window handle parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf3b7b168b64bb1abbfc17e93d0c5014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformSetClipboardString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the clipboard to the specified string. </p>
<p>This function sets the system clipboard to the specified, UTF-8 encoded string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window that will own the clipboard contents. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td><a class="el" href="structA.html">A</a> UTF-8 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The specified string is copied before this function returns.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>clipboard </dd>
<dd>
<a class="el" href="group__input.html#ga3ac90c8bbaf0b46063bb02b574f3b6f7" title="Returns the contents of the clipboard as a string. ">glfwGetClipboardString</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga52276580374c999cf4babdd49270afa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformSetCursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__GLFWcursor.html">_GLFWcursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the cursor for the window. </p>
<p>This function sets the cursor image to be used when the cursor is over the client area of the specified window. The set cursor will only be visible when the cursor mode of the window is <code>GLFW_CURSOR_NORMAL</code>.</p>
<p>On some platforms, the set cursor may not be visible unless the window also has input focus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window to set the cursor for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cursor</td><td>The cursor to set, or <code>NULL</code> to switch back to the default arrow cursor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cursor_object</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga710177640b2ec4ca911527ff47348d18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformSetCursorPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ypos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the position of the cursor, relative to the client area of the window. </p>
<p>This function sets the position, in screen coordinates, of the cursor relative to the upper-left corner of the client area of the specified window. The window must have input focus. If the window does not have input focus when this function is called, it fails silently.</p>
<p><b>Do not use this function</b> to implement things like camera controls. GLFW already provides the <code>GLFW_CURSOR_DISABLED</code> cursor mode that hides the cursor, transparently re-centers it and provides unconstrained cursor motion. See <a class="el" href="group__input.html#gae1eb729d2dd91dc33fd60e150a6e1684">glfwSetInputMode</a> for more information.</p>
<p>If the cursor mode is <code>GLFW_CURSOR_DISABLED</code> then the cursor position is unconstrained and limited only by the minimum and maximum values of a <code>double</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The desired window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpos</td><td>The desired x-coordinate, relative to the left edge of the client area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ypos</td><td>The desired y-coordinate, relative to the top edge of the client area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><b>X11:</b> Due to the asynchronous nature of X11, it may take a moment for the window focus event to arrive. This means you may not be able to set the cursor position directly after window creation.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cursor_pos </dd>
<dd>
<a class="el" href="group__input.html#gad289438eb7cf53d11eca685373f44105" title="Retrieves the position of the cursor relative to the client area of the window. ">glfwGetCursorPos</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. Replaces <code>glfwSetMousePos</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gabcaf1fc34700bd62b558caccce3ab45b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformSetGammaRamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWmonitor.html">_GLFWmonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGLFWgammaramp.html">GLFWgammaramp</a> *&#160;</td>
          <td class="paramname"><em>ramp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current gamma ramp for the specified monitor. </p>
<p>This function sets the current gamma ramp for the specified monitor. The original gamma ramp for that monitor is saved by GLFW the first time this function is called and is restored by <a class="el" href="group__init.html#gafd90e6fd4819ea9e22e5e739519a6504">glfwTerminate</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">monitor</td><td>The monitor whose gamma ramp to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ramp</td><td>The gamma ramp to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Gamma ramp sizes other than 256 are not supported by all platforms or graphics hardware.</dd>
<dd>
<b>Windows:</b> The gamma ramp size must be 256.</dd></dl>
<dl class="section user"><dt>Pointer Lifetime</dt><dd>The specified gamma ramp is copied before this function returns.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>monitor_gamma</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ec7765724b69e6e75a855e2363c298c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformSetTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the GLFW timer. </p>
<p>This function sets the value of the GLFW timer. It then continues to count up from that value. The value must be a positive finite number less than or equal to 18446744073.0, which is approximately 584.5 years.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The new value, in seconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The upper limit of the timer is calculated as floor((2<sup>64</sup> - 1) / 10<sup>9</sup>) and is due to implementations storing nanoseconds in 64 bits. The limit may be increased in the future.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>time</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 2.2. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0934dc13a91c13e63e4ad615c23be628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformSetWindowPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ypos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the position of the client area of the specified window. </p>
<p>This function sets the position, in screen coordinates, of the upper-left corner of the client area of the specified windowed mode window. If the window is a full screen window, this function does nothing.</p>
<p><b>Do not use this function</b> to move an already visible window unless you have very good reasons for doing so, as it will confuse and annoy the user.</p>
<p>The window manager may put limits on what positions are allowed. GLFW cannot and should not override these limits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window to query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpos</td><td>The x-coordinate of the upper-left corner of the client area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ypos</td><td>The y-coordinate of the upper-left corner of the client area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_pos </dd>
<dd>
<a class="el" href="group__window.html#ga0076a8591ef7494d359730cf2250b45b" title="Retrieves the position of the client area of the specified window. ">glfwGetWindowPos</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0.</dd></dl>
<dl class="section user"><dt></dt><dd><b>GLFW 3:</b> Added window handle parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga29ba7669f18179be6e7df88f9891db89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformSetWindowSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the client area of the specified window. </p>
<p>This function sets the size, in screen coordinates, of the client area of the specified window.</p>
<p>For full screen windows, this function selects and switches to the resolution closest to the specified size, without affecting the window's context. As the context is unaffected, the bit depths of the framebuffer remain unchanged.</p>
<p>The window manager may put limits on what sizes are allowed. GLFW cannot and should not override these limits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window to resize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The desired width of the specified window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The desired height of the specified window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_size </dd>
<dd>
<a class="el" href="group__window.html#ga7feb769ebb3f3d21579b5a3fb07be76e" title="Retrieves the size of the client area of the specified window. ">glfwGetWindowSize</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0.</dd></dl>
<dl class="section user"><dt></dt><dd><b>GLFW 3:</b> Added window handle parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed22dd224adc359c8aee05e1f7ccd92b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformSetWindowTitle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the title of the specified window. </p>
<p>This function sets the window title, encoded as UTF-8, of the specified window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window whose title to change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">title</td><td>The UTF-8 encoded window title.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><b>OS <a class="el" href="structX.html">X</a>:</b> The window title will not be updated until the next time you process events.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_title</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0.</dd></dl>
<dl class="section user"><dt></dt><dd><b>GLFW 3:</b> Added window handle parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="gabc4c51c7c430fab92aec7797734f44a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformShowWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the specified window visible. </p>
<p>This function makes the specified window visible if it was previously hidden. If the window is already visible or is in full screen mode, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window to make visible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>window_hide </dd>
<dd>
<a class="el" href="group__window.html#gaa17e287d521544bdeceafa09ac036e20" title="Hides the specified window. ">glfwHideWindow</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 3.0. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed52d436a3a5510e4bd252cbf5c76302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformSwapBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__GLFWwindow.html">_GLFWwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the front and back buffers of the specified window. </p>
<p>This function swaps the front and back buffers of the specified window. If the swap interval is greater than zero, the GPU driver waits the specified number of screen updates before swapping the buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>The window whose buffers to swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may be called from any thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>buffer_swap </dd>
<dd>
<a class="el" href="group__context.html#ga12a595c06947cec4967c6e1f14210a8a" title="Sets the swap interval for the current context. ">glfwSwapInterval</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0.</dd></dl>
<dl class="section user"><dt></dt><dd><b>GLFW 3:</b> Added window handle parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga06af35966bc5ea06f59cae87aca6c075"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformSwapInterval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the swap interval for the current context. </p>
<p>This function sets the swap interval for the current context, i.e. the number of screen updates to wait from the time <a class="el" href="group__window.html#gafb827800eedbfcbc97b1e5408df668d7">glfwSwapBuffers</a> was called before swapping the buffers and returning. This is sometimes called <em>vertical synchronization</em>, <em>vertical retrace synchronization</em> or just <em>vsync</em>.</p>
<p>Contexts that support either of the <code>WGL_EXT_swap_control_tear</code> and <code>GLX_EXT_swap_control_tear</code> extensions also accept negative swap intervals, which allow the driver to swap even if a frame arrives a little bit late. You can check for the presence of these extensions using <a class="el" href="group__context.html#ga9a28c712d35f9e43534e1d03b051c04c">glfwExtensionSupported</a>. For more information about swap tearing, see the extension specifications.</p>
<p><a class="el" href="structA.html">A</a> context must be current on the calling thread. Calling this function without a current context will cause a <a class="el" href="group__errors.html#gaa8290386e9528ccb9e42a3a4e16fc0d0">GLFW_NO_CURRENT_CONTEXT</a> error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>The minimum number of screen updates to wait for until the buffers are swapped by <a class="el" href="group__window.html#gafb827800eedbfcbc97b1e5408df668d7">glfwSwapBuffers</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not called during context creation, leaving the swap interval set to whatever is the default on that platform. This is done because some swap interval extensions used by GLFW do not allow the swap interval to be reset to zero once it has been set to a non-zero value.</dd>
<dd>
Some GPU drivers do not honor the requested swap interval, either because of a user setting that overrides the application's request or due to bugs in the driver.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may be called from any thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>buffer_swap </dd>
<dd>
<a class="el" href="group__window.html#gafb827800eedbfcbc97b1e5408df668d7" title="Swaps the front and back buffers of the specified window. ">glfwSwapBuffers</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 1.0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d4fd289ab03927d5856d8eb69977b9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _glfwPlatformWaitEvents </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until events are queued and processes them. </p>
<p>This function puts the calling thread to sleep until at least one event is available in the event queue. Once one or more events are available, it behaves exactly like <a class="el" href="group__window.html#ga872d16e4c77f58c0436f356255920cfc">glfwPollEvents</a>, i.e. the events in the queue are processed and the function then returns immediately. Processing events will cause the window and input callbacks associated with those events to be called.</p>
<p>Since not all events are associated with callbacks, this function may return without a callback having been called even if you are monitoring all callbacks.</p>
<p>On some platforms, a window move, resize or menu operation will cause event processing to block. This is due to how event processing is designed on those platforms. You can use the window refresh callback to redraw the contents of your window when necessary during such operations.</p>
<p>On some platforms, certain callbacks may be called outside of a call to one of the event processing functions.</p>
<p>If no windows exist, this function returns immediately. For synchronization of threads in applications that do not create windows, use your threading library of choice.</p>
<p>Event processing is not required for joystick input to work.</p>
<dl class="section user"><dt>Reentrancy</dt><dd>This function may not be called from a callback.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function may only be called from the main thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>events </dd>
<dd>
<a class="el" href="group__window.html#ga872d16e4c77f58c0436f356255920cfc" title="Processes all pending events. ">glfwPollEvents</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in GLFW 2.5. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 16 2016 17:37:18 for tetcutter by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
