\hypertarget{classLoki_1_1LevelMutexInfo}{}\section{Loki\+:\+:Level\+Mutex\+Info Class Reference}
\label{classLoki_1_1LevelMutexInfo}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}


{\ttfamily \#include $<$Level\+Mutex.\+h$>$}

Inheritance diagram for Loki\+:\+:Level\+Mutex\+Info\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classLoki_1_1LevelMutexInfo}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classLoki_1_1LevelMutexInfo_1_1Checker}{Checker}
\item 
class \hyperlink{classLoki_1_1LevelMutexInfo_1_1MutexUndoer}{Mutex\+Undoer}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a76a0315d91234f5066c75660a9f27a7f}{}typedef \+::std\+::vector$<$ volatile \hyperlink{classLoki_1_1LevelMutexInfo}{Level\+Mutex\+Info} $\ast$ $>$ \hyperlink{classLoki_1_1LevelMutexInfo_a76a0315d91234f5066c75660a9f27a7f}{Mutex\+Container}\label{classLoki_1_1LevelMutexInfo_a76a0315d91234f5066c75660a9f27a7f}

\begin{DoxyCompactList}\small\item\em Container for locking multiple mutexes at once. \end{DoxyCompactList}\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a113155a861291e24efb80ecb795ced42}{}typedef Mutex\+Container\+::iterator {\bfseries Level\+Mutex\+Container\+Iter}\label{classLoki_1_1LevelMutexInfo_a113155a861291e24efb80ecb795ced42}

\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a18a0f71a067b3c6028ca10010a740cee}{}typedef Mutex\+Container\+::const\+\_\+iterator {\bfseries Level\+Mutex\+Container\+C\+Iter}\label{classLoki_1_1LevelMutexInfo_a18a0f71a067b3c6028ca10010a740cee}

\item 
\hypertarget{classLoki_1_1LevelMutexInfo_aecc582d1025baad1f014d3604e293b4d}{}typedef Mutex\+Container\+::reverse\+\_\+iterator {\bfseries Level\+Mutex\+Container\+R\+Iter}\label{classLoki_1_1LevelMutexInfo_aecc582d1025baad1f014d3604e293b4d}

\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a4aedd07ffe486369939e0fb4c0bb1074}{}typedef Mutex\+Container\+::const\+\_\+reverse\+\_\+iterator {\bfseries Level\+Mutex\+Container\+C\+R\+Iter}\label{classLoki_1_1LevelMutexInfo_a4aedd07ffe486369939e0fb4c0bb1074}

\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classLoki_1_1LevelMutexInfo_abdedfcacd393739737f1792cdf5a1c85}{}unsigned int \hyperlink{classLoki_1_1LevelMutexInfo_abdedfcacd393739737f1792cdf5a1c85}{Get\+Level} (void) const  volatile\label{classLoki_1_1LevelMutexInfo_abdedfcacd393739737f1792cdf5a1c85}

\begin{DoxyCompactList}\small\item\em Returns the level of this mutex. \end{DoxyCompactList}\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a579b8448224912bb4d666ac8e0590541}{}bool \hyperlink{classLoki_1_1LevelMutexInfo_a579b8448224912bb4d666ac8e0590541}{Is\+Locked} (void) const  volatile\label{classLoki_1_1LevelMutexInfo_a579b8448224912bb4d666ac8e0590541}

\begin{DoxyCompactList}\small\item\em Returns true if this mutex was locked at least once. \end{DoxyCompactList}\item 
\hypertarget{classLoki_1_1LevelMutexInfo_abd8ad4b0cbc81c3875db1e1cb8c05e91}{}unsigned int \hyperlink{classLoki_1_1LevelMutexInfo_abd8ad4b0cbc81c3875db1e1cb8c05e91}{Get\+Lock\+Count} (void) const  volatile\label{classLoki_1_1LevelMutexInfo_abd8ad4b0cbc81c3875db1e1cb8c05e91}

\begin{DoxyCompactList}\small\item\em Returns count of how many times this mutex got locked. \end{DoxyCompactList}\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a73937a31d5902e74752708c3b2917327}{}const volatile \hyperlink{classLoki_1_1LevelMutexInfo}{Level\+Mutex\+Info} $\ast$ \hyperlink{classLoki_1_1LevelMutexInfo_a73937a31d5902e74752708c3b2917327}{Get\+Previous} (void) const  volatile\label{classLoki_1_1LevelMutexInfo_a73937a31d5902e74752708c3b2917327}

\begin{DoxyCompactList}\small\item\em Returns pointer to mutex previously locked by the thread which locked this. \end{DoxyCompactList}\item 
virtual \hyperlink{classLoki_1_1MutexErrors_acd0eb6065ca303083d2e0229d7bff590}{Mutex\+Errors\+::\+Type} \hyperlink{classLoki_1_1LevelMutexInfo_a32f89bf087b932de0cdd1151116779b4}{Try\+Lock} (void) volatile=0
\item 
virtual \hyperlink{classLoki_1_1MutexErrors_acd0eb6065ca303083d2e0229d7bff590}{Mutex\+Errors\+::\+Type} \hyperlink{classLoki_1_1LevelMutexInfo_ac0e21e08ee9974533a4da5008452bd04}{Lock} (void) volatile=0
\item 
virtual \hyperlink{classLoki_1_1MutexErrors_acd0eb6065ca303083d2e0229d7bff590}{Mutex\+Errors\+::\+Type} \hyperlink{classLoki_1_1LevelMutexInfo_a5782b9fd9734d95a38ff86ef9532c89b}{Lock} (unsigned int milli\+Seconds) volatile=0
\item 
virtual \hyperlink{classLoki_1_1MutexErrors_acd0eb6065ca303083d2e0229d7bff590}{Mutex\+Errors\+::\+Type} \hyperlink{classLoki_1_1LevelMutexInfo_a01c9af5cb0f6870585b864b4557e9242}{Unlock} (void) volatile=0
\item 
bool \hyperlink{classLoki_1_1LevelMutexInfo_ae2dd128d5864ad0ffe9fa55912e11c5c}{Is\+Recent\+Lock} (void) const  volatile
\item 
bool \hyperlink{classLoki_1_1LevelMutexInfo_acf885ea3edb574c902e61a9a97cd4933}{Is\+Recent\+Lock} (unsigned int count) const  volatile
\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a9bc33a319dd0aab4df4d95a557eeda0f}{}bool \hyperlink{classLoki_1_1LevelMutexInfo_a9bc33a319dd0aab4df4d95a557eeda0f}{Is\+Locked\+By\+Current\+Thread} (void) const  volatile\label{classLoki_1_1LevelMutexInfo_a9bc33a319dd0aab4df4d95a557eeda0f}

\begin{DoxyCompactList}\small\item\em Returns true if this was locked by current thread. \end{DoxyCompactList}\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a3c0f3e952926fca76d2921b47d3b9457}{}bool \hyperlink{classLoki_1_1LevelMutexInfo_a3c0f3e952926fca76d2921b47d3b9457}{Is\+Locked\+By\+Another\+Thread} (void) const  volatile\label{classLoki_1_1LevelMutexInfo_a3c0f3e952926fca76d2921b47d3b9457}

\begin{DoxyCompactList}\small\item\em Returns true if this was locked by another thread. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classLoki_1_1MutexErrors_acd0eb6065ca303083d2e0229d7bff590}{Mutex\+Errors\+::\+Type} \hyperlink{classLoki_1_1LevelMutexInfo_adde650eae1cad8b4723e68cdb9130283}{Multi\+Lock} (\hyperlink{classLoki_1_1LevelMutexInfo_a76a0315d91234f5066c75660a9f27a7f}{Mutex\+Container} \&mutexes)
\item 
static \hyperlink{classLoki_1_1MutexErrors_acd0eb6065ca303083d2e0229d7bff590}{Mutex\+Errors\+::\+Type} \hyperlink{classLoki_1_1LevelMutexInfo_aa76848d3aa8e6c66454bd5357f715583}{Multi\+Lock} (\hyperlink{classLoki_1_1LevelMutexInfo_a76a0315d91234f5066c75660a9f27a7f}{Mutex\+Container} \&mutexes, unsigned int milli\+Seconds)
\item 
static \hyperlink{classLoki_1_1MutexErrors_acd0eb6065ca303083d2e0229d7bff590}{Mutex\+Errors\+::\+Type} \hyperlink{classLoki_1_1LevelMutexInfo_a475d734ba0e756935462a5151ea98065}{Multi\+Unlock} (\hyperlink{classLoki_1_1LevelMutexInfo_a76a0315d91234f5066c75660a9f27a7f}{Mutex\+Container} \&mutexes)
\item 
static const volatile \hyperlink{classLoki_1_1LevelMutexInfo}{Level\+Mutex\+Info} $\ast$ \hyperlink{classLoki_1_1LevelMutexInfo_ab7fd94847721b118979b72121472d3e2}{Get\+Current\+Mutex} (void)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const unsigned int \hyperlink{classLoki_1_1LevelMutexInfo_a1f68bae408eb26856776cf02efed90bc}{Unlocked\+Level} = 0x\+F\+F\+F\+F\+F\+F\+F\+F
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classLoki_1_1LevelMutexInfo_a0e7b01d7e0aad6710f34de9811a88151}{Level\+Mutex\+Info} (unsigned int level)
\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a5d6713a7bc49313e970c91cfeb208d0e}{}virtual \hyperlink{classLoki_1_1LevelMutexInfo_a5d6713a7bc49313e970c91cfeb208d0e}{$\sim$\+Level\+Mutex\+Info} (void)\label{classLoki_1_1LevelMutexInfo_a5d6713a7bc49313e970c91cfeb208d0e}

\begin{DoxyCompactList}\small\item\em The destructor only gets called by the derived class. \end{DoxyCompactList}\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a648ffd0040be4464e342d45e8d029972}{}\hyperlink{classLoki_1_1MutexErrors_acd0eb6065ca303083d2e0229d7bff590}{Mutex\+Errors\+::\+Type} {\bfseries Pre\+Lock\+Check} (bool for\+Try\+Lock) volatile\label{classLoki_1_1LevelMutexInfo_a648ffd0040be4464e342d45e8d029972}

\item 
\hypertarget{classLoki_1_1LevelMutexInfo_adc21f5357f74a3b137dded520e35e489}{}\hyperlink{classLoki_1_1MutexErrors_acd0eb6065ca303083d2e0229d7bff590}{Mutex\+Errors\+::\+Type} {\bfseries Pre\+Unlock\+Check} (void) volatile\label{classLoki_1_1LevelMutexInfo_adc21f5357f74a3b137dded520e35e489}

\item 
void \hyperlink{classLoki_1_1LevelMutexInfo_a3fe2ecf1bcf2c49eae04c493f023099c}{Post\+Lock} (void) volatile
\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a7d5e2ace54e9423866be7c76116423df}{}void \hyperlink{classLoki_1_1LevelMutexInfo_a7d5e2ace54e9423866be7c76116423df}{Pre\+Unlock} (void) volatile\label{classLoki_1_1LevelMutexInfo_a7d5e2ace54e9423866be7c76116423df}

\begin{DoxyCompactList}\small\item\em Gets called just before an attempt to unlock a mutex. \end{DoxyCompactList}\item 
\hypertarget{classLoki_1_1LevelMutexInfo_ab31292dd7d1a944b8db2ba39a8487f3b}{}void \hyperlink{classLoki_1_1LevelMutexInfo_ab31292dd7d1a944b8db2ba39a8487f3b}{Increment\+Count} (void) volatile\label{classLoki_1_1LevelMutexInfo_ab31292dd7d1a944b8db2ba39a8487f3b}

\begin{DoxyCompactList}\small\item\em Called to relock a mutex already locked by the current thread. \end{DoxyCompactList}\item 
\hypertarget{classLoki_1_1LevelMutexInfo_a929c6964d78855d487a4fd72ef8e3332}{}void \hyperlink{classLoki_1_1LevelMutexInfo_a929c6964d78855d487a4fd72ef8e3332}{Decrement\+Count} (void) volatile\label{classLoki_1_1LevelMutexInfo_a929c6964d78855d487a4fd72ef8e3332}

\begin{DoxyCompactList}\small\item\em Called to unlock a mutex locked multiple times by the current thread. \end{DoxyCompactList}\item 
bool \hyperlink{classLoki_1_1LevelMutexInfo_a479a20cf2f8da0ef5bed07cdef45b119}{Is\+Valid} (void) const  volatile
\end{DoxyCompactItemize}
\subsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{classLoki_1_1LevelMutexInfo_a01f6dfba5d2ea5606109b34e5a543cf0}{Is\+Valid\+List} (void)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This monolithic base class stores common info for a template class used to control mutexes. The template class, \hyperlink{classLoki_1_1LevelMutex}{Level\+Mutex}, is policy-\/based class.

\begin{DoxyParagraph}{Implementation}
Each thread has a list of mutexes it locked. When a mutex first gets locked, it gets added to the head of the list. If locked again, \hyperlink{classLoki_1_1LevelMutex}{Level\+Mutex} merely increments a count. When unlocked, the count gets decremented until it reaches zero, and then it gets removed from the list. Each mutex has a pointer to the mutex most recently locked by the current thread. The current level of a thread is always the level of the most recently locked mutex, or Unlocked\+Level if the thread does not have any mutexes locked now. \hyperlink{structA}{A} mutex is considered \char`\"{}recently\char`\"{} locked if it is at the head of the list, or the same level as the current mutex and also locked by the current thread.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Class Invariants}
This class maintains invariants for each \hyperlink{classLoki_1_1LevelMutexInfo}{Level\+Mutex\+Info} so that no function calls corrupt a mutex. Each function makes a call to Is\+Valid at the start so that \hyperlink{classLoki_1_1LevelMutex}{Level\+Mutex} knows it acts on valid internal data. Many functions call Is\+Valid again when they return to insure the function did not leave any data in an invalid state. The exit call to Is\+Valid occurs through a tiny helper class called \hyperlink{classLoki_1_1LevelMutexInfo_1_1Checker}{Checker} to insure all data remain valid even when exceptions occur. Another helper class, \hyperlink{classLoki_1_1LevelMutexInfo_1_1MutexUndoer}{Mutex\+Undoer}, unlocks mutexes in a container if an exception occurs during calls to Multi\+Lock.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Error Results}
Many functions return an enum value to indicate an error status. Many enum values indicate errors detected within \hyperlink{classLoki_1_1LevelMutex}{Level\+Mutex}, but some indicate errors found in policy classes, \hyperlink{classLoki_1_1SpinLevelMutex}{Spin\+Level\+Mutex} and \hyperlink{classLoki_1_1SleepLevelMutex}{Sleep\+Level\+Mutex}. 
\end{DoxyParagraph}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classLoki_1_1LevelMutexInfo_a0e7b01d7e0aad6710f34de9811a88151}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Level\+Mutex\+Info@{Level\+Mutex\+Info}}
\index{Level\+Mutex\+Info@{Level\+Mutex\+Info}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Level\+Mutex\+Info(unsigned int level)}]{\setlength{\rightskip}{0pt plus 5cm}Loki\+::\+Level\+Mutex\+Info\+::\+Level\+Mutex\+Info (
\begin{DoxyParamCaption}
\item[{unsigned int}]{level}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [explicit]}, {\ttfamily [protected]}}\label{classLoki_1_1LevelMutexInfo_a0e7b01d7e0aad6710f34de9811a88151}
This is the only available constructor, and it forces any derived class to set a level for each mutex. 

\subsection{Member Function Documentation}
\hypertarget{classLoki_1_1LevelMutexInfo_ab7fd94847721b118979b72121472d3e2}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Get\+Current\+Mutex@{Get\+Current\+Mutex}}
\index{Get\+Current\+Mutex@{Get\+Current\+Mutex}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Get\+Current\+Mutex(void)}]{\setlength{\rightskip}{0pt plus 5cm}const volatile {\bf Level\+Mutex\+Info} $\ast$ Loki\+::\+Level\+Mutex\+Info\+::\+Get\+Current\+Mutex (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classLoki_1_1LevelMutexInfo_ab7fd94847721b118979b72121472d3e2}
Gives pointer to most recently locked mutex, or N\+U\+L\+L if nothing locked. The pointer is for a const mutex so the mutex can\textquotesingle{}t be modified inappropriately. The pointer is for a volatile mutex so callers can call volatile member functions to get info about the mutex. \hypertarget{classLoki_1_1LevelMutexInfo_ae2dd128d5864ad0ffe9fa55912e11c5c}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Is\+Recent\+Lock@{Is\+Recent\+Lock}}
\index{Is\+Recent\+Lock@{Is\+Recent\+Lock}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Is\+Recent\+Lock(void) const  volatile}]{\setlength{\rightskip}{0pt plus 5cm}bool Loki\+::\+Level\+Mutex\+Info\+::\+Is\+Recent\+Lock (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const volatile}\label{classLoki_1_1LevelMutexInfo_ae2dd128d5864ad0ffe9fa55912e11c5c}
Returns true if this mutex was locked by current thread, and level is the same as the current thread\textquotesingle{}s level. Which means this was the most recently locked mutex, or it was locked along with several others of the same level recently. \hypertarget{classLoki_1_1LevelMutexInfo_acf885ea3edb574c902e61a9a97cd4933}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Is\+Recent\+Lock@{Is\+Recent\+Lock}}
\index{Is\+Recent\+Lock@{Is\+Recent\+Lock}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Is\+Recent\+Lock(unsigned int count) const  volatile}]{\setlength{\rightskip}{0pt plus 5cm}bool Loki\+::\+Level\+Mutex\+Info\+::\+Is\+Recent\+Lock (
\begin{DoxyParamCaption}
\item[{unsigned int}]{count}
\end{DoxyParamCaption}
) const volatile}\label{classLoki_1_1LevelMutexInfo_acf885ea3edb574c902e61a9a97cd4933}
Returns true if this mutex was locked within the last count mutexes. 
\begin{DoxyParams}{Parameters}
{\em count} & How many recent mutexes to look through to find this mutex. \\
\hline
\end{DoxyParams}
\hypertarget{classLoki_1_1LevelMutexInfo_a479a20cf2f8da0ef5bed07cdef45b119}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Is\+Valid@{Is\+Valid}}
\index{Is\+Valid@{Is\+Valid}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Is\+Valid(void) const  volatile}]{\setlength{\rightskip}{0pt plus 5cm}bool Loki\+::\+Level\+Mutex\+Info\+::\+Is\+Valid (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const volatile\hspace{0.3cm}{\ttfamily [protected]}}\label{classLoki_1_1LevelMutexInfo_a479a20cf2f8da0ef5bed07cdef45b119}
Returns true if no class invariant broken, otherwise asserts. This function only gets called in debug builds. \hypertarget{classLoki_1_1LevelMutexInfo_a01f6dfba5d2ea5606109b34e5a543cf0}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Is\+Valid\+List@{Is\+Valid\+List}}
\index{Is\+Valid\+List@{Is\+Valid\+List}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Is\+Valid\+List(void)}]{\setlength{\rightskip}{0pt plus 5cm}bool Loki\+::\+Level\+Mutex\+Info\+::\+Is\+Valid\+List (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}\label{classLoki_1_1LevelMutexInfo_a01f6dfba5d2ea5606109b34e5a543cf0}
Returns true if linked-\/list of locked mutexes in this thread is valid. Which means the list has no loops, and each previous mutex on the list has a higher or same level as the current mutex. Called by Is\+Valid. \hypertarget{classLoki_1_1LevelMutexInfo_ac0e21e08ee9974533a4da5008452bd04}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Lock@{Lock}}
\index{Lock@{Lock}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Lock(void) volatile=0}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Mutex\+Errors\+::\+Type} Loki\+::\+Level\+Mutex\+Info\+::\+Lock (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) volatile\hspace{0.3cm}{\ttfamily [pure virtual]}}\label{classLoki_1_1LevelMutexInfo_ac0e21e08ee9974533a4da5008452bd04}
Blocking call will attempt to lock mutex and wait until it can lock. This may throw an exception if the lock failed or an error occurred -\/ if that is what the error policy specifies. \begin{DoxyReturn}{Returns}
An error condition if any occurred, else Success. 
\end{DoxyReturn}


Implemented in \hyperlink{classLoki_1_1LevelMutex_a95d3742db062548201986f482a9c9b9d}{Loki\+::\+Level\+Mutex$<$ Mutex\+Policy, Default\+Level, Error\+Policy, Wait\+Policy $>$}.

\hypertarget{classLoki_1_1LevelMutexInfo_a5782b9fd9734d95a38ff86ef9532c89b}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Lock@{Lock}}
\index{Lock@{Lock}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Lock(unsigned int milli\+Seconds) volatile=0}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Mutex\+Errors\+::\+Type} Loki\+::\+Level\+Mutex\+Info\+::\+Lock (
\begin{DoxyParamCaption}
\item[{unsigned int}]{milli\+Seconds}
\end{DoxyParamCaption}
) volatile\hspace{0.3cm}{\ttfamily [pure virtual]}}\label{classLoki_1_1LevelMutexInfo_a5782b9fd9734d95a38ff86ef9532c89b}
Attempts to lock mutex, but only waits for a limited amount of time before it gives up. Will return quickly if an error occurs before any attempt to lock. This may throw an exception if the lock failed or an error occurred -\/ if that is what the error policy specifies. 
\begin{DoxyParams}{Parameters}
{\em milli\+Seconds} & How long to wait. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An error condition if any occurred, else Success. 
\end{DoxyReturn}


Implemented in \hyperlink{classLoki_1_1LevelMutex_ad4ac0c2a33ff3d98ec0a83f70ce145da}{Loki\+::\+Level\+Mutex$<$ Mutex\+Policy, Default\+Level, Error\+Policy, Wait\+Policy $>$}.

\hypertarget{classLoki_1_1LevelMutexInfo_adde650eae1cad8b4723e68cdb9130283}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Multi\+Lock@{Multi\+Lock}}
\index{Multi\+Lock@{Multi\+Lock}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Multi\+Lock(\+Mutex\+Container \&mutexes)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mutex\+Errors\+::\+Type} Loki\+::\+Level\+Mutex\+Info\+::\+Multi\+Lock (
\begin{DoxyParamCaption}
\item[{{\bf Mutex\+Container} \&}]{mutexes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classLoki_1_1LevelMutexInfo_adde650eae1cad8b4723e68cdb9130283}
Locks several mutexes at once. Requires O(m + n$\ast$n) actions where m is the number of mutexes currently locked by the thread and n is the number of mutexes in the container. This provides strong exception safety. If an exception occurs, any mutexes that were locked during this call will get unlocked. 
\begin{DoxyParams}{Parameters}
{\em mutexes} & Container of pointers to mutexes. Container must have at least 1 mutex, all mutexes must have the same level, no N\+U\+L\+L pointers, and all mutexes must not exceed the thread\textquotesingle{}s current level. This sorts the container by address order. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Enum value indicating success or error. 
\end{DoxyReturn}
\hypertarget{classLoki_1_1LevelMutexInfo_aa76848d3aa8e6c66454bd5357f715583}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Multi\+Lock@{Multi\+Lock}}
\index{Multi\+Lock@{Multi\+Lock}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Multi\+Lock(\+Mutex\+Container \&mutexes, unsigned int milli\+Seconds)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mutex\+Errors\+::\+Type} Loki\+::\+Level\+Mutex\+Info\+::\+Multi\+Lock (
\begin{DoxyParamCaption}
\item[{{\bf Mutex\+Container} \&}]{mutexes, }
\item[{unsigned int}]{milli\+Seconds}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classLoki_1_1LevelMutexInfo_aa76848d3aa8e6c66454bd5357f715583}
Locks several mutexes at once. Requires O(m + n$\ast$n + n$\ast$t) actions where m is the number of mutexes currently locked by the thread, n is the number of mutexes in the container, and t is the wait time for each mutex. This provides strong exception safety. If an exception occurs, any mutexes that were locked during this call will ge unlocked. 
\begin{DoxyParams}{Parameters}
{\em mutexes} & Container of pointers to mutexes. Container must have at least 1 mutex, all mutexes must have the same level, no N\+U\+L\+L pointers, and all mutexes must not exceed the thread\textquotesingle{}s current level. This sorts the container by address order. \\
\hline
{\em milli\+Seconds} & Amount of time to wait for each mutex. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Enum value indicating success or error. 
\end{DoxyReturn}
\hypertarget{classLoki_1_1LevelMutexInfo_a475d734ba0e756935462a5151ea98065}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Multi\+Unlock@{Multi\+Unlock}}
\index{Multi\+Unlock@{Multi\+Unlock}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Multi\+Unlock(\+Mutex\+Container \&mutexes)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mutex\+Errors\+::\+Type} Loki\+::\+Level\+Mutex\+Info\+::\+Multi\+Unlock (
\begin{DoxyParamCaption}
\item[{{\bf Mutex\+Container} \&}]{mutexes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classLoki_1_1LevelMutexInfo_a475d734ba0e756935462a5151ea98065}
Unlocks several mutexes at once. Requires O(m) actions where m is the number of mutexes in the container. This provides strong exception safety. If an exception occurs when unlocking one mutex, other mutexes in the container get unlocked anyway. 
\begin{DoxyParams}{Parameters}
{\em mutexes} & Container of pointers to mutexes. Container must have at least 1 mutex, all mutexes must have the same level, no N\+U\+L\+L pointers, and all mutexes must be locked by the current thread. This sorts the container dby address order. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Enum value indicating success or error. 
\end{DoxyReturn}
\hypertarget{classLoki_1_1LevelMutexInfo_a3fe2ecf1bcf2c49eae04c493f023099c}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Post\+Lock@{Post\+Lock}}
\index{Post\+Lock@{Post\+Lock}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Post\+Lock(void) volatile}]{\setlength{\rightskip}{0pt plus 5cm}void Loki\+::\+Level\+Mutex\+Info\+::\+Post\+Lock (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) volatile\hspace{0.3cm}{\ttfamily [protected]}}\label{classLoki_1_1LevelMutexInfo_a3fe2ecf1bcf2c49eae04c493f023099c}
This gets called after each call to Do\+Lock and Do\+Try\+Lock to make sure the data members in this object get set correctly. \hypertarget{classLoki_1_1LevelMutexInfo_a32f89bf087b932de0cdd1151116779b4}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Try\+Lock@{Try\+Lock}}
\index{Try\+Lock@{Try\+Lock}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Try\+Lock(void) volatile=0}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Mutex\+Errors\+::\+Type} Loki\+::\+Level\+Mutex\+Info\+::\+Try\+Lock (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) volatile\hspace{0.3cm}{\ttfamily [pure virtual]}}\label{classLoki_1_1LevelMutexInfo_a32f89bf087b932de0cdd1151116779b4}
Tries to lock mutex, and returns immediately if mutex already locked by another thread. It will return immediately with a value of Already\+Locked if the mutex was locked by a different thread. It may throw an exception or assert when errors occur if the Error\+Policy class implements that behavior. \begin{DoxyReturn}{Returns}
An error condition if any occurred, else Success. 
\end{DoxyReturn}


Implemented in \hyperlink{classLoki_1_1LevelMutex_a042a7938dafd6f149cfd7da46478c0c9}{Loki\+::\+Level\+Mutex$<$ Mutex\+Policy, Default\+Level, Error\+Policy, Wait\+Policy $>$}.

\hypertarget{classLoki_1_1LevelMutexInfo_a01c9af5cb0f6870585b864b4557e9242}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Unlock@{Unlock}}
\index{Unlock@{Unlock}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Unlock(void) volatile=0}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Mutex\+Errors\+::\+Type} Loki\+::\+Level\+Mutex\+Info\+::\+Unlock (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) volatile\hspace{0.3cm}{\ttfamily [pure virtual]}}\label{classLoki_1_1LevelMutexInfo_a01c9af5cb0f6870585b864b4557e9242}
Unlocks the mutex, or returns an error condition. This may throw an exception if the lock failed or an error occurred -\/ if that is what the error policy specifies. \begin{DoxyReturn}{Returns}
An error condition if any occurred, else Success. 
\end{DoxyReturn}


Implemented in \hyperlink{classLoki_1_1LevelMutex_a553a379257af57ceaef9ed48b0dc8b70}{Loki\+::\+Level\+Mutex$<$ Mutex\+Policy, Default\+Level, Error\+Policy, Wait\+Policy $>$}.



\subsection{Member Data Documentation}
\hypertarget{classLoki_1_1LevelMutexInfo_a1f68bae408eb26856776cf02efed90bc}{}\index{Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}!Unlocked\+Level@{Unlocked\+Level}}
\index{Unlocked\+Level@{Unlocked\+Level}!Loki\+::\+Level\+Mutex\+Info@{Loki\+::\+Level\+Mutex\+Info}}
\subsubsection[{Unlocked\+Level}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned int Loki\+::\+Level\+Mutex\+Info\+::\+Unlocked\+Level = 0x\+F\+F\+F\+F\+F\+F\+F\+F\hspace{0.3cm}{\ttfamily [static]}}\label{classLoki_1_1LevelMutexInfo_a1f68bae408eb26856776cf02efed90bc}
Level for thread that has not locked any mutex. Maximum possible level for a mutex is Unlocked\+Level-\/1; No mutex may have a level of Unlocked\+Level. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/\+Users/pourya/\+Desktop/platform/repos/tetcutter/src/3rdparty/loki/include/loki/\hyperlink{LevelMutex_8h}{Level\+Mutex.\+h}\item 
/\+Users/pourya/\+Desktop/platform/repos/tetcutter/src/3rdparty/loki/src/\hyperlink{LevelMutex_8cpp}{Level\+Mutex.\+cpp}\end{DoxyCompactItemize}
