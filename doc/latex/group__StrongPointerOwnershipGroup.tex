\hypertarget{group__StrongPointerOwnershipGroup}{}\section{Strong\+Ptr Ownership policies}
\label{group__StrongPointerOwnershipGroup}\index{Strong\+Ptr Ownership policies@{Strong\+Ptr Ownership policies}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classLoki_1_1Private_1_1TwoRefCountInfo}{Loki\+::\+Private\+::\+Two\+Ref\+Count\+Info}
\item 
class \hyperlink{classLockableTwoRefCountInfo}{Lockable\+Two\+Ref\+Count\+Info}
\item 
class \hyperlink{classLoki_1_1TwoRefCounts}{Loki\+::\+Two\+Ref\+Counts}
\item 
class \hyperlink{classLockableTwoRefCounts}{Lockable\+Two\+Ref\+Counts}
\item 
class \hyperlink{classLoki_1_1TwoRefLinks}{Loki\+::\+Two\+Ref\+Links}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyParagraph}{Terminology}
These terms are used within this file\textquotesingle{}s comments.
\begin{DoxyEnumerate}
\item Strong\+Ptr \+: Class used to implement both strong and weak pointers. The second template parameter determines if a Strong\+Ptr is weak or strong.
\item Strong pointer \+: \hyperlink{structA}{A} pointer that claims ownership of a shared object. When the last strong copointer dies, the object is destroyed even if there are weak copointers.
\item Weak pointer \+: \hyperlink{structA}{A} pointer that does not own the shared object it points to. It only destroys the shared object if there no strong copointers exist when it dies.
\item Copointers \+: All the pointers that refer to the same shared object. The copointers must have the same ownership policy, but the other policies may be different.
\item Pointee \+: The shared object.
\end{DoxyEnumerate}
\end{DoxyParagraph}
\begin{DoxyParagraph}{Ownership\+Policy}
The ownership policy has the pointer to the actual object, and it also keeps track of the strong and weak copointers so that it can know if any strong copointers remain. The plain pointer it maintains is stored as a void pointer, which allows the ownership policy classes to be monolithic classes instead of template classes. As monolithic classes, they reduce amount of code-\/bloat.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Writing Your Own Ownership\+Policy}
If you write your own policy, you must implement these 12 functions\+:
\begin{DoxyEnumerate}
\item explicit Your\+Policy( bool strong )
\item Your\+Policy( void $\ast$ p, bool strong )
\item Your\+Policy( const Your\+Policy \& rhs, bool strong )
\item bool Release( bool strong )
\item void Increment( bool strong )
\item bool Decrement( bool strong )
\item bool Has\+Strong\+Pointer( void ) const
\item void Swap( Your\+Policy \& rhs )
\item void Set\+Pointer( void $\ast$ p )
\item void Zap\+Pointer( void )
\item void $\ast$ Get\+Pointer( void ) const
\item void $\ast$ \& Get\+Pointer\+Ref( void ) const It is strongly recommended that all 12 of these functions be protected instead of public. These two functions are optional for single-\/threaded policies, but required for multi-\/threaded policies\+:
\item void Lock( void ) const
\item void Unlock( void ) const This function is entirely optional\+:
\item bool Merge( Two\+Ref\+Links \& rhs )
\end{DoxyEnumerate}
\end{DoxyParagraph}
\begin{DoxyParagraph}{Delete\+Policy}
The delete policy provides a mechanism to destroy an object and a default value for an uninitialized pointer. You can override this policy with your own when using the \hyperlink{classSingleton}{Singleton}, Null\+Object, or Prototype design patterns.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Writing Your Own Delete\+Policy}
If you write your own policy, you must implement these 3 functions\+:
\begin{DoxyEnumerate}
\item void static Delete( const P $\ast$ p )
\item static P $\ast$ Default( void )
\item void Swap( Your\+Reset\+Policy \& )
\end{DoxyEnumerate}
\end{DoxyParagraph}
\begin{DoxyParagraph}{Reset\+Policy}
\hyperlink{structA}{A} reset policy tells the Release\+All and Reset\+All functions whether they should release or reset the Strong\+Ptr copointers. These functions do not affect just one Strong\+Ptr, but all copointers. That is unlike Smart\+Ptr where the Release and Reset functions only affect 1 Smart\+Ptr, and leave all copointers untouched. \hyperlink{structA}{A} useful trick you can do with the Reset\+Policy is to not allow reset when a strong pointer exists, and then use the No\+Check policy for all strong pointers. The reset policy guarantees the strong pointers always have a valid pointee, so checking is not required; but weak pointers may still require checking.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Writing Your Own Reset\+Policy}
If you write your own policy, you must implement these 2 functions\+:
\begin{DoxyEnumerate}
\item bool On\+Release\+All( bool ) const
\item bool On\+Reset\+All( bool ) const The bool parameter means that this was called with a strong pointer or one of its copointers is strong. The return value means the pointer can be reset or released. 
\end{DoxyEnumerate}
\end{DoxyParagraph}
