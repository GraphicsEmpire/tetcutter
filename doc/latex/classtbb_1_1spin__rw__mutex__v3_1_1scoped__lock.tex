\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock}{}\section{tbb\+:\+:spin\+\_\+rw\+\_\+mutex\+\_\+v3\+:\+:scoped\+\_\+lock Class Reference}
\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock}\index{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock}}


The scoped locking pattern.  




{\ttfamily \#include $<$spin\+\_\+rw\+\_\+mutex.\+h$>$}

Inheritance diagram for tbb\+:\+:spin\+\_\+rw\+\_\+mutex\+\_\+v3\+:\+:scoped\+\_\+lock\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a285b355121772c874a7ecaaf4d347224}{scoped\+\_\+lock} ()
\begin{DoxyCompactList}\small\item\em Construct lock that has not acquired a mutex. \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a0a2e15358575f7651446bca13a5a2674}{}\hyperlink{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a0a2e15358575f7651446bca13a5a2674}{scoped\+\_\+lock} (\hyperlink{classtbb_1_1spin__rw__mutex}{spin\+\_\+rw\+\_\+mutex} \&m, bool write=true)\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a0a2e15358575f7651446bca13a5a2674}

\begin{DoxyCompactList}\small\item\em Acquire lock on given mutex. \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a5c27ca2e0c9db960a9a7430082ff7edd}{}\hyperlink{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a5c27ca2e0c9db960a9a7430082ff7edd}{$\sim$scoped\+\_\+lock} ()\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a5c27ca2e0c9db960a9a7430082ff7edd}

\begin{DoxyCompactList}\small\item\em Release lock (if lock is held). \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a6d49df365396ab314e78ba07c6b96433}{}void \hyperlink{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a6d49df365396ab314e78ba07c6b96433}{acquire} (\hyperlink{classtbb_1_1spin__rw__mutex}{spin\+\_\+rw\+\_\+mutex} \&m, bool write=true)\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a6d49df365396ab314e78ba07c6b96433}

\begin{DoxyCompactList}\small\item\em Acquire lock on given mutex. \end{DoxyCompactList}\item 
bool \hyperlink{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_afbe5de57eadc457518df7a1bb0d30c00}{upgrade\+\_\+to\+\_\+writer} ()
\begin{DoxyCompactList}\small\item\em Upgrade reader to become a writer. \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a99e279a995a51abfb87b865e886949f8}{}void \hyperlink{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a99e279a995a51abfb87b865e886949f8}{release} ()\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a99e279a995a51abfb87b865e886949f8}

\begin{DoxyCompactList}\small\item\em Release lock. \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_aa693c05221d977856a98270a255fe5df}{}bool \hyperlink{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_aa693c05221d977856a98270a255fe5df}{downgrade\+\_\+to\+\_\+reader} ()\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_aa693c05221d977856a98270a255fe5df}

\begin{DoxyCompactList}\small\item\em Downgrade writer to become a reader. \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_abf17ada91882fd70f139c503c0220f16}{}bool \hyperlink{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_abf17ada91882fd70f139c503c0220f16}{try\+\_\+acquire} (\hyperlink{classtbb_1_1spin__rw__mutex}{spin\+\_\+rw\+\_\+mutex} \&m, bool write=true)\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_abf17ada91882fd70f139c503c0220f16}

\begin{DoxyCompactList}\small\item\em Try acquire lock on given mutex. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a8d70c5a2348e30a6979bfbf677328dc4}{}\hyperlink{classtbb_1_1spin__rw__mutex}{spin\+\_\+rw\+\_\+mutex} $\ast$ \hyperlink{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a8d70c5a2348e30a6979bfbf677328dc4}{mutex}\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a8d70c5a2348e30a6979bfbf677328dc4}

\begin{DoxyCompactList}\small\item\em The pointer to the current mutex that is held, or N\+U\+L\+L if no mutex is held. \end{DoxyCompactList}\item 
bool \hyperlink{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_acfd129dc5106ad1129ba803e67311050}{is\+\_\+writer}
\begin{DoxyCompactList}\small\item\em If mutex!=N\+U\+L\+L, then is\+\_\+writer is true if holding a writer lock, false if holding a reader lock. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The scoped locking pattern. 

It helps to avoid the common problem of forgetting to release lock. It also nicely provides the \char`\"{}node\char`\"{} for queuing locks. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a285b355121772c874a7ecaaf4d347224}{}\index{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock}!scoped\+\_\+lock@{scoped\+\_\+lock}}
\index{scoped\+\_\+lock@{scoped\+\_\+lock}!tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock}}
\subsubsection[{scoped\+\_\+lock()}]{\setlength{\rightskip}{0pt plus 5cm}tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock\+::scoped\+\_\+lock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_a285b355121772c874a7ecaaf4d347224}


Construct lock that has not acquired a mutex. 

Equivalent to zero-\/initialization of $\ast$this. 

\subsection{Member Function Documentation}
\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_afbe5de57eadc457518df7a1bb0d30c00}{}\index{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock}!upgrade\+\_\+to\+\_\+writer@{upgrade\+\_\+to\+\_\+writer}}
\index{upgrade\+\_\+to\+\_\+writer@{upgrade\+\_\+to\+\_\+writer}!tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock}}
\subsubsection[{upgrade\+\_\+to\+\_\+writer()}]{\setlength{\rightskip}{0pt plus 5cm}bool tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock\+::upgrade\+\_\+to\+\_\+writer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_afbe5de57eadc457518df7a1bb0d30c00}


Upgrade reader to become a writer. 

Returns whether the upgrade happened without releasing and re-\/acquiring the lock 

\subsection{Member Data Documentation}
\hypertarget{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_acfd129dc5106ad1129ba803e67311050}{}\index{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock}!is\+\_\+writer@{is\+\_\+writer}}
\index{is\+\_\+writer@{is\+\_\+writer}!tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock}}
\subsubsection[{is\+\_\+writer}]{\setlength{\rightskip}{0pt plus 5cm}bool tbb\+::spin\+\_\+rw\+\_\+mutex\+\_\+v3\+::scoped\+\_\+lock\+::is\+\_\+writer\hspace{0.3cm}{\ttfamily [protected]}}\label{classtbb_1_1spin__rw__mutex__v3_1_1scoped__lock_acfd129dc5106ad1129ba803e67311050}


If mutex!=N\+U\+L\+L, then is\+\_\+writer is true if holding a writer lock, false if holding a reader lock. 

Not defined if not holding a lock. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/pourya/\+Desktop/platform/repos/tetcutter/src/3rdparty/tbb/include/tbb/spin\+\_\+rw\+\_\+mutex.\+h\end{DoxyCompactItemize}
