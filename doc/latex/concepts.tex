\hyperlink{structA}{A} concept is a set of requirements to a type, which are necessary and sufficient for the type to model a particular behavior or a set of behaviors. Some concepts are specific to a particular algorithm (e.\+g. algorithm body), while other ones are common to several algorithms (e.\+g. range concept).

All T\+B\+B algorithms make use of different classes implementing various concepts. Implementation classes are supplied by the user as type arguments of template parameters and/or as objects passed as function call arguments. The library provides predefined implementations of some concepts (e.\+g. several kinds of \hyperlink{range_req}{ranges}), while other ones must always be implemented by the user.

T\+B\+B defines a set of minimal requirements each concept must conform to. Here is the list of different concepts hyperlinked to the corresponding requirements specifications\+:
\begin{DoxyItemize}
\item \hyperlink{range_req}{Requirements on range concept}
\item \hyperlink{parallel_do_body_req}{Requirements on parallel\+\_\+do body}
\item \hyperlink{parallel_for_body_req}{Requirements on parallel\+\_\+for body}
\item \hyperlink{parallel_reduce_body_req}{Requirements on parallel\+\_\+reduce body}
\item \hyperlink{parallel_scan_body_req}{Requirements on parallel\+\_\+scan body}
\item \hyperlink{parallel_sort_iter_req}{Requirements on iterators for parallel\+\_\+sort} 
\end{DoxyItemize}\hypertarget{range_req}{}\section{Requirements on range concept}\label{range_req}
Class {\ttfamily R} implementing the concept of range must define\+:
\begin{DoxyItemize}
\item 
\begin{DoxyCode}
R::R( \textcolor{keyword}{const} R& ); 
\end{DoxyCode}
 Copy constructor
\item 
\begin{DoxyCode}
R::~R(); 
\end{DoxyCode}
 Destructor
\item 
\begin{DoxyCode}
\textcolor{keywordtype}{bool} R::is\_divisible() \textcolor{keyword}{const}; 
\end{DoxyCode}
 True if range can be partitioned into two subranges
\item 
\begin{DoxyCode}
\textcolor{keywordtype}{bool} R::empty() \textcolor{keyword}{const}; 
\end{DoxyCode}
 True if range is empty
\item 
\begin{DoxyCode}
R::R( R& r, split ); 
\end{DoxyCode}
 Split range {\ttfamily r} into two subranges. 
\end{DoxyItemize}\hypertarget{parallel_do_body_req}{}\section{Requirements on parallel\+\_\+do body}\label{parallel_do_body_req}
Class {\ttfamily \hyperlink{classBody}{Body}} implementing the concept of parallel\+\_\+do body must define\+:
\begin{DoxyItemize}
\item 
\begin{DoxyCode}
B::operator()( 
        cv\_item\_type item,
        parallel\_do\_feeder<item\_type>& feeder
) \textcolor{keyword}{const}

OR

B::operator()( cv\_item\_type& item ) \textcolor{keyword}{const}
\end{DoxyCode}
 Process item. May be invoked concurrently for the same {\ttfamily this} but different {\ttfamily item}.
\item 
\begin{DoxyCode}
item\_type( \textcolor{keyword}{const} item\_type& ) 
\end{DoxyCode}
 Copy a work item.
\item 
\begin{DoxyCode}
~item\_type() 
\end{DoxyCode}
 Destroy a work item 
\end{DoxyItemize}\hypertarget{parallel_for_body_req}{}\section{Requirements on parallel\+\_\+for body}\label{parallel_for_body_req}
Class {\ttfamily \hyperlink{classBody}{Body}} implementing the concept of parallel\+\_\+for body must define\+:
\begin{DoxyItemize}
\item 
\begin{DoxyCode}
Body::Body( \textcolor{keyword}{const} \hyperlink{classBody}{Body}& ); 
\end{DoxyCode}
 Copy constructor
\item 
\begin{DoxyCode}
Body::~Body(); 
\end{DoxyCode}
 Destructor
\item 
\begin{DoxyCode}
\textcolor{keywordtype}{void} Body::operator()( \hyperlink{classtbb_1_1blocked__range}{Range}& r ) \textcolor{keyword}{const}; 
\end{DoxyCode}
 Function call operator applying the body to range {\ttfamily r}. 
\end{DoxyItemize}\hypertarget{parallel_reduce_body_req}{}\section{Requirements on parallel\+\_\+reduce body}\label{parallel_reduce_body_req}
Class {\ttfamily \hyperlink{classBody}{Body}} implementing the concept of parallel\+\_\+reduce body must define\+:
\begin{DoxyItemize}
\item 
\begin{DoxyCode}
Body::Body( \hyperlink{classBody}{Body}&, split ); 
\end{DoxyCode}
 Splitting constructor. Must be able to run concurrently with operator() and method {\ttfamily join} 
\item 
\begin{DoxyCode}
Body::~Body(); 
\end{DoxyCode}
 Destructor
\item 
\begin{DoxyCode}
\textcolor{keywordtype}{void} Body::operator()( \hyperlink{classtbb_1_1blocked__range}{Range}& r ); 
\end{DoxyCode}
 Function call operator applying body to range {\ttfamily r} and accumulating the result
\item 
\begin{DoxyCode}
\textcolor{keywordtype}{void} Body::join( \hyperlink{classBody}{Body}& b ); 
\end{DoxyCode}
 Join results. The result in {\ttfamily b} should be merged into the result of {\ttfamily this} 
\end{DoxyItemize}\hypertarget{parallel_scan_body_req}{}\section{Requirements on parallel\+\_\+scan body}\label{parallel_scan_body_req}
Class {\ttfamily \hyperlink{classBody}{Body}} implementing the concept of parallel\+\_\+scan body must define\+:
\begin{DoxyItemize}
\item 
\begin{DoxyCode}
Body::Body( \hyperlink{classBody}{Body}&, split ); 
\end{DoxyCode}
 Splitting constructor. Split {\ttfamily b} so that {\ttfamily this} and {\ttfamily b} can accumulate separately
\item 
\begin{DoxyCode}
Body::~Body(); 
\end{DoxyCode}
 Destructor
\item 
\begin{DoxyCode}
\textcolor{keywordtype}{void} Body::operator()( \textcolor{keyword}{const} \hyperlink{classtbb_1_1blocked__range}{Range}& r, pre\_scan\_tag ); 
\end{DoxyCode}
 Preprocess iterations for range {\ttfamily r} 
\item 
\begin{DoxyCode}
\textcolor{keywordtype}{void} Body::operator()( \textcolor{keyword}{const} \hyperlink{classtbb_1_1blocked__range}{Range}& r, final\_scan\_tag ); 
\end{DoxyCode}
 Do final processing for iterations of range {\ttfamily r} 
\item 
\begin{DoxyCode}
\textcolor{keywordtype}{void} Body::reverse\_join( \hyperlink{classBody}{Body}& a ); 
\end{DoxyCode}
 Merge preprocessing state of {\ttfamily a} into {\ttfamily this}, where {\ttfamily a} was created earlier from {\ttfamily b} by b\textquotesingle{}s splitting constructor 
\end{DoxyItemize}\hypertarget{parallel_sort_iter_req}{}\section{Requirements on iterators for parallel\+\_\+sort}\label{parallel_sort_iter_req}
Requirements on value type {\ttfamily T} of {\ttfamily Random\+Access\+Iterator} for {\ttfamily parallel\+\_\+sort\+:} 
\begin{DoxyItemize}
\item 
\begin{DoxyCode}
\textcolor{keywordtype}{void} swap( T& x, T& y ) 
\end{DoxyCode}
 Swaps {\ttfamily x} and {\ttfamily y} 
\item 
\begin{DoxyCode}
\textcolor{keywordtype}{bool} Compare::operator()( \textcolor{keyword}{const} T& x, \textcolor{keyword}{const} T& y ) 
\end{DoxyCode}
 True if x comes before y; 
\end{DoxyItemize}