\hypertarget{structparallel__put__until__limit}{}\section{parallel\+\_\+put\+\_\+until\+\_\+limit$<$ Input\+Type $>$ Struct Template Reference}
\label{structparallel__put__until__limit}\index{parallel\+\_\+put\+\_\+until\+\_\+limit$<$ Input\+Type $>$@{parallel\+\_\+put\+\_\+until\+\_\+limit$<$ Input\+Type $>$}}


Performs test on function nodes with limited concurrency and buffering.  


Inheritance diagram for parallel\+\_\+put\+\_\+until\+\_\+limit$<$ Input\+Type $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{structparallel__put__until__limit}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{structparallel__put__until__limit_a2f682e794569050736334ff4a3f4a0d9}{}{\bfseries parallel\+\_\+put\+\_\+until\+\_\+limit} (\hyperlink{structharness__counting__sender}{harness\+\_\+counting\+\_\+sender}$<$ Input\+Type $>$ $\ast$senders)\label{structparallel__put__until__limit_a2f682e794569050736334ff4a3f4a0d9}

\item 
\hypertarget{structparallel__put__until__limit_a194aadfe587a5d18f80169c904b69750}{}void {\bfseries operator()} (int i) const \label{structparallel__put__until__limit_a194aadfe587a5d18f80169c904b69750}

\item 
\hypertarget{structparallel__put__until__limit_a2f682e794569050736334ff4a3f4a0d9}{}{\bfseries parallel\+\_\+put\+\_\+until\+\_\+limit} (\hyperlink{structharness__counting__sender}{harness\+\_\+counting\+\_\+sender}$<$ Input\+Type $>$ $\ast$senders)\label{structparallel__put__until__limit_a2f682e794569050736334ff4a3f4a0d9}

\item 
\hypertarget{structparallel__put__until__limit_a194aadfe587a5d18f80169c904b69750}{}void {\bfseries operator()} (int i) const \label{structparallel__put__until__limit_a194aadfe587a5d18f80169c904b69750}

\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{structparallel__put__until__limit_a950728ca715c15400df02e9fd837994a}{}\hyperlink{structharness__counting__sender}{harness\+\_\+counting\+\_\+sender}$<$ Input\+Type $>$ $\ast$ {\bfseries my\+\_\+senders}\label{structparallel__put__until__limit_a950728ca715c15400df02e9fd837994a}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Input\+Type$>$struct parallel\+\_\+put\+\_\+until\+\_\+limit$<$ Input\+Type $>$}

Performs test on function nodes with limited concurrency and buffering. 

Theses tests check\+: 1) that the number of executing copies never exceed the concurrency limit 2) that the node never rejects 3) that no items are lost and 4) all of this happens even if there are multiple predecessors and successors 

The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/\+Users/pourya/\+Desktop/platform/repos/tetcutter/src/3rdparty/tbb/src/test/test\+\_\+function\+\_\+node.\+cpp\item 
/\+Users/pourya/\+Desktop/platform/repos/tetcutter/src/3rdparty/tbb/src/test/test\+\_\+multifunction\+\_\+node.\+cpp\end{DoxyCompactItemize}
