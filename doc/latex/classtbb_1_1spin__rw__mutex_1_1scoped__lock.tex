\hypertarget{classtbb_1_1spin__rw__mutex_1_1scoped__lock}{}\section{tbb\+:\+:spin\+\_\+rw\+\_\+mutex\+:\+:scoped\+\_\+lock Class Reference}
\label{classtbb_1_1spin__rw__mutex_1_1scoped__lock}\index{tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock}}


The scoped locking pattern.  




{\ttfamily \#include $<$spin\+\_\+rw\+\_\+mutex\+\_\+v2.\+h$>$}

Inheritance diagram for tbb\+:\+:spin\+\_\+rw\+\_\+mutex\+:\+:scoped\+\_\+lock\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classtbb_1_1spin__rw__mutex_1_1scoped__lock}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a65696273b99d103d52067f648c7cf781}{scoped\+\_\+lock} ()
\begin{DoxyCompactList}\small\item\em Construct lock that has not acquired a mutex. \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex_1_1scoped__lock_ad81b258e5e08ceae857a52633c43fc70}{}\hyperlink{classtbb_1_1spin__rw__mutex_1_1scoped__lock_ad81b258e5e08ceae857a52633c43fc70}{scoped\+\_\+lock} (\hyperlink{classtbb_1_1spin__rw__mutex}{spin\+\_\+rw\+\_\+mutex} \&m, bool write=true)\label{classtbb_1_1spin__rw__mutex_1_1scoped__lock_ad81b258e5e08ceae857a52633c43fc70}

\begin{DoxyCompactList}\small\item\em Construct and acquire lock on given mutex. \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a970a354169106f8700e02c210e78f508}{}\hyperlink{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a970a354169106f8700e02c210e78f508}{$\sim$scoped\+\_\+lock} ()\label{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a970a354169106f8700e02c210e78f508}

\begin{DoxyCompactList}\small\item\em Release lock (if lock is held). \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a712147de02598365defe35076ca9ec3f}{}void \hyperlink{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a712147de02598365defe35076ca9ec3f}{acquire} (\hyperlink{classtbb_1_1spin__rw__mutex}{spin\+\_\+rw\+\_\+mutex} \&m, bool write=true)\label{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a712147de02598365defe35076ca9ec3f}

\begin{DoxyCompactList}\small\item\em Acquire lock on given mutex. \end{DoxyCompactList}\item 
bool \hyperlink{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a5bb48b38f4ef2e4eda0ee64187b9f941}{upgrade\+\_\+to\+\_\+writer} ()
\begin{DoxyCompactList}\small\item\em Upgrade reader to become a writer. \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex_1_1scoped__lock_add1ba1f93fcb3676084dcaf6a5a367f8}{}void \hyperlink{classtbb_1_1spin__rw__mutex_1_1scoped__lock_add1ba1f93fcb3676084dcaf6a5a367f8}{release} ()\label{classtbb_1_1spin__rw__mutex_1_1scoped__lock_add1ba1f93fcb3676084dcaf6a5a367f8}

\begin{DoxyCompactList}\small\item\em Release lock. \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a9028aeeeca09e2964e197297988df9f2}{}bool \hyperlink{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a9028aeeeca09e2964e197297988df9f2}{downgrade\+\_\+to\+\_\+reader} ()\label{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a9028aeeeca09e2964e197297988df9f2}

\begin{DoxyCompactList}\small\item\em Downgrade writer to become a reader. \end{DoxyCompactList}\item 
\hypertarget{classtbb_1_1spin__rw__mutex_1_1scoped__lock_aed236c523ea40e19212f7f5c0b7db166}{}bool \hyperlink{classtbb_1_1spin__rw__mutex_1_1scoped__lock_aed236c523ea40e19212f7f5c0b7db166}{try\+\_\+acquire} (\hyperlink{classtbb_1_1spin__rw__mutex}{spin\+\_\+rw\+\_\+mutex} \&m, bool write=true)\label{classtbb_1_1spin__rw__mutex_1_1scoped__lock_aed236c523ea40e19212f7f5c0b7db166}

\begin{DoxyCompactList}\small\item\em Try acquire lock on given mutex. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The scoped locking pattern. 

It helps to avoid the common problem of forgetting to release lock. It also nicely provides the \char`\"{}node\char`\"{} for queuing locks. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a65696273b99d103d52067f648c7cf781}{}\index{tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock}!scoped\+\_\+lock@{scoped\+\_\+lock}}
\index{scoped\+\_\+lock@{scoped\+\_\+lock}!tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock}}
\subsubsection[{scoped\+\_\+lock()}]{\setlength{\rightskip}{0pt plus 5cm}{\bf tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock\+::scoped\+\_\+lock} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a65696273b99d103d52067f648c7cf781}


Construct lock that has not acquired a mutex. 

Equivalent to zero-\/initialization of $\ast$this. 

\subsection{Member Function Documentation}
\hypertarget{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a5bb48b38f4ef2e4eda0ee64187b9f941}{}\index{tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock}!upgrade\+\_\+to\+\_\+writer@{upgrade\+\_\+to\+\_\+writer}}
\index{upgrade\+\_\+to\+\_\+writer@{upgrade\+\_\+to\+\_\+writer}!tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock@{tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock}}
\subsubsection[{upgrade\+\_\+to\+\_\+writer()}]{\setlength{\rightskip}{0pt plus 5cm}bool tbb\+::spin\+\_\+rw\+\_\+mutex\+::scoped\+\_\+lock\+::upgrade\+\_\+to\+\_\+writer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classtbb_1_1spin__rw__mutex_1_1scoped__lock_a5bb48b38f4ef2e4eda0ee64187b9f941}


Upgrade reader to become a writer. 

Returns whether the upgrade happened without releasing and re-\/acquiring the lock 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/pourya/\+Desktop/platform/repos/tetcutter/src/3rdparty/tbb/src/old/spin\+\_\+rw\+\_\+mutex\+\_\+v2.\+h\end{DoxyCompactItemize}
