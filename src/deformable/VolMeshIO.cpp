/*
 * VolMeshExport.cpp
 *
 *  Created on: Aug 16, 2014
 *      Author: pourya
 */

#include "VolMeshIO.h"
#include "base/FileDirectory.h"
#include "base/Logger.h"
#include "base/FlatArray.h"
#include "graphics/Mesh.h"
#include <fstream>

using namespace std;
using namespace PS::MESH;
using namespace PS::FILESTRINGUTILS;

bool VolMeshIO::readVega(VolMesh* vm, const AnsiStr& strPath) {

	if ((vm == NULL) || !FileExists(strPath))
		return false;
	char chrLine[1024];
	ifstream fpIn(strPath.cptr());
	if (!fpIn.is_open())
		return false;


	vector<double> vertices;
	vector<U32> elements;

	U32 ctLine = 0;

	U32 idxVertex = 0;
	U32 ctVertices = 0;
	U32 ctVertexStep = 0;

	U32 idxElement = 0;
	U32 ctElements = 0;
	U32 ctElementStep = 0;

	enum READMODE {
		modeReadHeader, modeReadVertex, modeReadElements,
		modeReadMaterial, modeReadRegion
	};

	READMODE mode = modeReadHeader;
	READMODE prevMode = mode;

	while (!fpIn.eof()) {
		fpIn.getline(chrLine, 1024);

		AnsiStr strLine(chrLine);
		strLine.trim();
		strLine.removeStartEndSpaces();
		if (strLine.length() == 0)
			continue;

		if (strLine.firstChar() == '#')
			continue;
		if (strLine.firstChar() == '*') {
			vector<AnsiStr> tokens;
			strLine.decompose(' ', tokens);
			if (tokens[0] == "*VERTICES")
				mode = modeReadVertex;
			else if (tokens[0] == "*ELEMENTS")
				mode = modeReadElements;
			else if (tokens[0] == "*MATERIAL")
				mode = modeReadMaterial;
			else if (tokens[0] == "*REGION")
				mode = modeReadRegion;

			continue;
		}
		else if(strLine == "TETS")
			continue;

		//count tokens
		{
			vector<AnsiStr> tokens;
			int ctTokens = strLine.decompose(' ', tokens);
			if(ctTokens < 2)
				continue;
		}

		if (prevMode != mode) {
			if (mode == modeReadVertex && idxVertex == 0) {
				sscanf(strLine.cptr(), "%u %u", &ctVertices, &ctVertexStep);
				if (ctVertices <= 0 || ctVertexStep != 3) {
					fpIn.close();
					return false;
				}

				vertices.reserve(ctVertices * ctVertexStep);
				prevMode = mode;
				continue;
			} else if (mode == modeReadElements && idxElement == 0) {
				sscanf(strLine.cptr(), "%u %u", &ctElements, &ctElementStep);
				if (ctElements <= 0 || ctElementStep != 4) {
					fpIn.close();
					return false;
				}

				elements.reserve(ctElements * ctElementStep);
				prevMode = mode;
				continue;
			}
		}

		if (mode == modeReadVertex) {
			vec3d v;
			vector<AnsiStr> arrWords;
			int ctWords = strLine.decompose(' ', arrWords);

			if (ctWords >= 4) {
				U32 row = atoi(arrWords[0].cptr()) - 1;
				assert(row == idxVertex);

				v.x = atof(arrWords[1].cptr());
				v.y = atof(arrWords[2].cptr());
				v.z = atof(arrWords[3].cptr());
			}

			//add vertex to the array
			vertices.push_back(v.x);
			vertices.push_back(v.y);
			vertices.push_back(v.z);
			idxVertex++;

		} else if (mode == modeReadElements) {
			vec4u32 e;
			vector<AnsiStr> arrWords;
			int ctWords = strLine.decompose(' ', arrWords);
			if (ctWords >= 5) {
				U32 row = atoi(arrWords[0].cptr()) - 1;
				assert(row == idxElement);

				e.x = atoi(arrWords[1].cptr()) - 1;
				e.y = atoi(arrWords[2].cptr()) - 1;
				e.z = atoi(arrWords[3].cptr()) - 1;
				e.w = atoi(arrWords[4].cptr()) - 1;
			}

			//add element to the array
			elements.push_back(e.x);
			elements.push_back(e.y);
			elements.push_back(e.z);
			elements.push_back(e.w);

			idxElement++;
		}

		prevMode = mode;
		ctLine++;
	}
	fpIn.close();

	//check read amount
	if((vertices.size() / ctVertexStep) != ctVertices)
		return false;

	if((elements.size() / ctElementStep) != ctElements)
		return false;

	//setup mesh
	vm->cleanup();
	vm->setName(ExtractFileTitleOnly(strPath).cptr());
	return vm->setup(vertices, elements);
}

bool VolMeshIO::writeVega(const VolMesh* vm, const AnsiStr& strPath) {
	if(vm == NULL)
		return false;

	if (vm->countNodes() == 0 || vm->countCells() == 0)
		return false;

	//Output veg file
	AnsiStr strVegFP = ChangeFileExt(strPath, ".veg");
	ofstream fpOut(strVegFP.cptr());

	//Include Node File
	fpOut << "# Vega Mesh File, Generated by FemBrain.\n";
	fpOut << "# " << vm->countNodes() << " vertices, " << vm->countCells() << " elements\n";
	fpOut << "\n";
	fpOut << "*VERTICES\n";
	fpOut << vm->countNodes() << " 3 0 0\n";

	for (U32 i = 0; i < vm->countNodes(); i++) {
		vec3d v = vm->const_nodeAt(i).pos;

		//VEGA expects one based index for everything
		fpOut << i + 1 << " " << v.x << " " << v.y << " " << v.z << "\n";
	}

	//Line Separator
	fpOut << "\n";
	fpOut << "*ELEMENTS\n";
	fpOut << "TET\n";
	fpOut << vm->countCells() << " 4 0\n";

	for (U32 i = 0; i < vm->countCells(); i++) {
		const CELL& cell = vm->const_cellAt(i);
		vec4u32 n = vec4u32(&cell.nodes[0]);

		//VEGA expects one based index for everything
		fpOut << i + 1 << " " << n.x + 1 << " " << n.y + 1 << " " << n.z + 1
				<< " " << n.w + 1 << "\n";
	}

	//Add Default Material
	fpOut << "\n";
	fpOut << "*MATERIAL BODY\n";
	fpOut << "ENU, 1000, 10000000, 0.45\n";

	fpOut << "\n";
	fpOut << "*REGION\n";
	fpOut << "allElements, BODY\n";

	//Include Element File
	fpOut.close();

	return true;
}

bool VolMeshIO::writeObj(const VolMesh* vm, const AnsiStr& strPath) {

	if(vm == NULL)
		return false;

	Mesh objMesh;
	MeshNode* aNode = new MeshNode();

	//output nodes
	for (U32 i = 0; i < vm->countNodes(); i++) {
		vec3d v = vm->const_nodeAt(i).pos;

		aNode->addVertex(vec3f(v.x, v.y, v.z));
	}

	//output cell faces
	for (U32 i = 0; i < vm->countCells(); i++) {
		const CELL& cell = vm->const_cellAt(i);
		U32 nodes[3];

		for(U32 j=0; j < COUNT_CELL_FACES; j++) {

			vm->getFaceNodes(cell.faces[j], nodes);
			aNode->addTriangle(nodes);
		}
	}

	//
	objMesh.addNode(aNode);
	return objMesh.store(strPath.cptr());
}

bool VolMeshIO::fitmesh(VolMesh* vm, const AABB& toBox) {
	if(!toBox.isValid())
		return false;

	AABB curBox = vm->computeAABB();

	vec3f s = vec3f::div(toBox.extent(), curBox.extent());
	double minScaleFactor = MATHMIN(MATHMIN(s.x, s.y), s.z);
	vec3d scale(minScaleFactor);

	vec3f t = toBox.lower() - curBox.lower();
	vec3d translate(t.x, t.y, t.z);


	//first translate all nodes
	for(U32 i=0; i < vm->countNodes(); i++) {
		NODE& p = vm->nodeAt(i);

		//translate
		p.pos = p.pos + translate;
		p.restpos = p.restpos + translate;

		//scale
		p.pos = p.pos * minScaleFactor;
		p.restpos = p.restpos * minScaleFactor;
	}

	return true;
}

bool VolMeshIO::rotatemesh(VolMesh* vm, const quatd& quat) {
	if(vm == NULL)
		return false;

	quatd qInv = quat.inverted();

	//first translate all nodes
	for(U32 i=0; i < vm->countNodes(); i++) {
		NODE& p = vm->nodeAt(i);

		p.pos = quat.transform(qInv, p.pos);
		p.restpos = quat.transform(qInv, p.restpos);
	}

	return true;
}

bool VolMeshIO::convertMatlabTextToVega(const AnsiStr& strNodesFP,
										const AnsiStr& strFacesFP,
										const AnsiStr& strCellsFP) {
	//	node: node coordinates (in mm)
	//		face: surface triangles; the last column is the surface ID,
	//			1-scalp, 2-CSF, 3-gray matter, 4-white matter
	//		elem: tetrahedral elements; the last column is the region ID,
	//			1-scalp and skull layer, 2-CSF, 3-gray matter, 4-white matter
	if(!FileExists(strNodesFP) || !FileExists(strCellsFP)) {
		LogError("Invalid input file!");
		return false;
	}


	vector<vec3d> nodes;
	ifstream fpNodes(strNodesFP.cptr());
	if (!fpNodes.is_open())
		return false;

	//read nodes
	U32 ctLine = 0;
	char chrLine[1024];
	while (!fpNodes.eof()) {
		fpNodes.getline(chrLine, 1024);

		AnsiStr strLine(chrLine);
		strLine.trim();
		strLine.removeStartEndSpaces();
		if (strLine.length() == 0)
			continue;

		if (strLine.firstChar() == '#')
			continue;

		//count tokens
		{
			vector<AnsiStr> tokens;
			int ctTokens = strLine.decompose(',', tokens);
			if(ctTokens < 2)
				continue;

			vec3d v;
			v.x = atof(tokens[0].cptr());
			v.y = atof(tokens[1].cptr());
			v.z = atof(tokens[2].cptr());
			nodes.push_back(v);
		}
		ctLine++;
	}
	fpNodes.close();



	vector< vector<U32> > vBrainSegmentCells;
	vBrainSegmentCells.resize(4);


	//read cells
	ifstream fpCells(strCellsFP.cptr());
	if (!fpCells.is_open())
		return false;

	U32 ctExpectedTokens = 5;
	vector<U32> vConvTokens;
	vConvTokens.resize(ctExpectedTokens);

	while (!fpCells.eof()) {
		fpCells.getline(chrLine, 1024);

		AnsiStr strLine(chrLine);
		strLine.trim();
		strLine.removeStartEndSpaces();
		if (strLine.length() == 0)
			continue;

		if (strLine.firstChar() == '#')
			continue;

		//count tokens
		{
			vector<AnsiStr> tokens;
			int ctTokens = strLine.decompose(',', tokens);
			if(ctTokens < 2)
				continue;

			for(U32 i=0; i < ctExpectedTokens; i++)
				vConvTokens[i] = atoi(tokens[i].cptr());

			U32 idxSegment = vConvTokens.back() - 1;
			for(U32 i=0; i < ctExpectedTokens - 1; i++)
				vBrainSegmentCells[idxSegment].push_back(vConvTokens[i] - 1);
		}
	}
	fpCells.close();


	//export brain segments
	enum BrainSegment {bsSkull = 1, bsCSF = 2, bsGrayMatter = 3, bsWhiteMatter = 4};
	string arrSegmentTitles[4] = {"skull", "csf", "graymatter", "whitematter"};


	AnsiStr strRoot = ExtractFilePath(strNodesFP);

	//export segments
	for(U32 i=0; i < 4; i++) {
		vector<U32> vFlatCells(vBrainSegmentCells[i].begin(), vBrainSegmentCells[i].end());

		vector<vec3d> vFinalNodes;
		vFinalNodes.reserve(nodes.size());

		map<U32, U32> mapSegmentNodes;

		//Make a unique set of nodes
		for(U32 j=0; j < vFlatCells.size(); j++) {

			//if not found in cache the add it
			if(mapSegmentNodes.find(vFlatCells[j]) == mapSegmentNodes.end()) {
				vFinalNodes.push_back(nodes[vFlatCells[j] ]);
				U32 idxNewNode = vFinalNodes.size() - 1;
				mapSegmentNodes[ vFlatCells[j] ] = idxNewNode;
			}

			//convert to the new node index
			vFlatCells[j] = mapSegmentNodes[ vFlatCells[j] ];
		}

		//clear the map
		mapSegmentNodes.clear();

		vector<double> vFlatNodes;
		FlattenVec3<double>(vFinalNodes, vFlatNodes);
		VolMesh* pvm = new VolMesh(vFlatNodes, vFlatCells);
		pvm->setVerbose(true);

//		quatd q;
//		q.fromAxisAngle(vec3d(0, 0, 1), 90.0);
//		rotatemesh(pvm, q);

		//aabb
//		AABB box1(vec3f(0.0f, 0.0f, 0.0f), vec3f(4.0f, 4.0f, 4.0f));
//		fitmesh(pvm, box1);


		//aabb
		AABB box2(vec3f(-2.0f, 0.0f, -2.0f), vec3f(2.0f, 4.0f, 2.0f));
		fitmesh(pvm, box2);

		AnsiStr strFP = strRoot + AnsiStr(arrSegmentTitles[i].c_str()) + AnsiStr(".veg");
		if(writeVega(pvm, strFP)) {
			LogInfoArg2("Saved segment %s to %s", arrSegmentTitles[i].c_str(), strFP.cptr());
		}

		SAFE_DELETE(pvm);
	}

	return true;
}

