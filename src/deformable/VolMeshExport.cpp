/*
 * VolMeshExport.cpp
 *
 *  Created on: Aug 16, 2014
 *      Author: pourya
 */

#include "VolMeshExport.h"
#include "base/FileDirectory.h"
#include "graphics/Mesh.h"
#include <fstream>

using namespace std;
using namespace PS::MESH;
using namespace PS::FILESTRINGUTILS;

bool VolMeshIO::readVega(VolMesh* vm, const AnsiStr& strPath) {

	if ((vm == NULL) || !FileExists(strPath))
		return false;
	char chrLine[1024];
	ifstream fpIn(strPath.cptr());
	if (!fpIn.is_open())
		return false;


	vector<double> vertices;
	vector<U32> elements;

	U32 ctLine = 0;

	U32 idxVertex = 0;
	U32 ctVertices = 0;
	U32 ctVertexStep = 0;

	U32 idxElement = 0;
	U32 ctElements = 0;
	U32 ctElementStep = 0;

	enum READMODE {
		modeReadHeader, modeReadVertex, modeReadElements,
		modeReadMaterial, modeReadRegion
	};

	READMODE mode = modeReadHeader;
	READMODE prevMode = mode;

	while (!fpIn.eof()) {
		fpIn.getline(chrLine, 1024);

		AnsiStr strLine(chrLine);
		strLine.trim();
		strLine.removeStartEndSpaces();
		if (strLine.length() == 0)
			continue;

		if (strLine.firstChar() == '#')
			continue;
		if (strLine.firstChar() == '*') {
			vector<AnsiStr> tokens;
			strLine.decompose(' ', tokens);
			if (tokens[0] == "*VERTICES")
				mode = modeReadVertex;
			else if (tokens[0] == "*ELEMENTS")
				mode = modeReadElements;
			else if (tokens[0] == "*MATERIAL")
				mode = modeReadMaterial;
			else if (tokens[0] == "*REGION")
				mode = modeReadRegion;

			continue;
		}
		else if(strLine == "TETS")
			continue;

		//count tokens
		{
			vector<AnsiStr> tokens;
			int ctTokens = strLine.decompose(' ', tokens);
			if(ctTokens < 2)
				continue;
		}

		if (prevMode != mode) {
			if (mode == modeReadVertex && idxVertex == 0) {
				sscanf(strLine.cptr(), "%u %u", &ctVertices, &ctVertexStep);
				if (ctVertices <= 0 || ctVertexStep != 3) {
					fpIn.close();
					return false;
				}

				vertices.reserve(ctVertices * ctVertexStep);
				prevMode = mode;
				continue;
			} else if (mode == modeReadElements && idxElement == 0) {
				sscanf(strLine.cptr(), "%u %u", &ctElements, &ctElementStep);
				if (ctElements <= 0 || ctElementStep != 4) {
					fpIn.close();
					return false;
				}

				elements.reserve(ctElements * ctElementStep);
				prevMode = mode;
				continue;
			}
		}

		if (mode == modeReadVertex) {
			vec3d v;
			vector<AnsiStr> arrWords;
			int ctWords = strLine.decompose(' ', arrWords);

			if (ctWords >= 4) {
				U32 row = atoi(arrWords[0].cptr()) - 1;
				assert(row == idxVertex);

				v.x = atof(arrWords[1].cptr());
				v.y = atof(arrWords[2].cptr());
				v.z = atof(arrWords[3].cptr());
			}

			//add vertex to the array
			vertices.push_back(v.x);
			vertices.push_back(v.y);
			vertices.push_back(v.z);
			idxVertex++;

		} else if (mode == modeReadElements) {
			vec4u32 e;
			vector<AnsiStr> arrWords;
			int ctWords = strLine.decompose(' ', arrWords);
			if (ctWords >= 5) {
				U32 row = atoi(arrWords[0].cptr()) - 1;
				assert(row == idxElement);

				e.x = atoi(arrWords[1].cptr()) - 1;
				e.y = atoi(arrWords[2].cptr()) - 1;
				e.z = atoi(arrWords[3].cptr()) - 1;
				e.w = atoi(arrWords[4].cptr()) - 1;
			}

			//add element to the array
			elements.push_back(e.x);
			elements.push_back(e.y);
			elements.push_back(e.z);
			elements.push_back(e.w);

			idxElement++;
		}

		prevMode = mode;
		ctLine++;
	}
	fpIn.close();

	//check read amount
	if((vertices.size() / ctVertexStep) != ctVertices)
		return false;

	if((elements.size() / ctElementStep) != ctElements)
		return false;

	//setup mesh
	vm->cleanup();
	vm->setName(ExtractFileTitleOnly(strPath).cptr());
	return vm->setup(vertices, elements);
}

bool VolMeshIO::writeVega(const VolMesh* vm, const AnsiStr& strPath) {
	if(vm == NULL)
		return false;

	if (vm->countNodes() == 0 || vm->countCells() == 0)
		return false;

	//Output veg file
	AnsiStr strVegFP = ChangeFileExt(strPath, ".veg");
	ofstream fpOut(strVegFP.cptr());

	//Include Node File
	fpOut << "# Vega Mesh File, Generated by FemBrain.\n";
	fpOut << "# " << vm->countNodes() << " vertices, " << vm->countCells() << " elements\n";
	fpOut << "\n";
	fpOut << "*VERTICES\n";
	fpOut << vm->countNodes() << " 3 0 0\n";

	for (U32 i = 0; i < vm->countNodes(); i++) {
		vec3d v = vm->const_nodeAt(i).pos;

		//VEGA expects one based index for everything
		fpOut << i + 1 << " " << v.x << " " << v.y << " " << v.z << "\n";
	}

	//Line Separator
	fpOut << "\n";
	fpOut << "*ELEMENTS\n";
	fpOut << "TET\n";
	fpOut << vm->countCells() << " 4 0\n";

	for (U32 i = 0; i < vm->countCells(); i++) {
		const CELL& cell = vm->const_cellAt(i);
		vec4u32 n = vec4u32(&cell.nodes[0]);

		//VEGA expects one based index for everything
		fpOut << i + 1 << " " << n.x + 1 << " " << n.y + 1 << " " << n.z + 1
				<< " " << n.w + 1 << "\n";
	}

	//Add Default Material
	fpOut << "\n";
	fpOut << "*MATERIAL BODY\n";
	fpOut << "ENU, 1000, 10000000, 0.45\n";

	fpOut << "\n";
	fpOut << "*REGION\n";
	fpOut << "allElements, BODY\n";

	//Include Element File
	fpOut.close();

	return true;
}

bool VolMeshIO::writeObj(const VolMesh* vm, const AnsiStr& strPath) {

	if(vm == NULL)
		return false;

	Mesh objMesh;
	MeshNode* aNode = new MeshNode();

	//output nodes
	for (U32 i = 0; i < vm->countNodes(); i++) {
		vec3d v = vm->const_nodeAt(i).pos;

		aNode->addVertex(vec3f(v.x, v.y, v.z));
	}

	//output cell faces
	for (U32 i = 0; i < vm->countCells(); i++) {
		const CELL& cell = vm->const_cellAt(i);
		U32 nodes[3];

		for(U32 j=0; j < COUNT_CELL_FACES; j++) {

			vm->getFaceNodes(cell.faces[j], nodes);
			aNode->addTriangle(nodes);
		}
	}

	//
	objMesh.addNode(aNode);
	return objMesh.store(strPath.cptr());
}

